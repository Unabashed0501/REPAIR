{"instance_id": "astropy__astropy-6938", "found_files": ["astropy/io/fits/fitsrec.py", "astropy/io/fits/column.py", "astropy/io/fits/util.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/io/fits/fitsrec.py": ["function: FITS_rec._scale_back_ascii\nfunction: encode_ascii"], "astropy/io/fits/column.py": [""], "astropy/io/fits/util.py": [""]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/io/fits/fitsrec.py\nfunction: FITS_rec._scale_back_ascii\nfunction: encode_ascii\n```"}], "related_loc_traj": [{"response": "```\nastropy/io/fits/fitsrec.py\nfunction: FITS_rec._scale_back_ascii\nfunction: encode_ascii\n```", "usage": {"completion_tokens": 29, "prompt_tokens": 4629}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nPossible bug in io.fits related to D exponents\nI came across the following code in ``fitsrec.py``:\r\n\r\n```python\r\n        # Replace exponent separator in floating point numbers\r\n        if 'D' in format:\r\n            output_field.replace(encode_ascii('E'), encode_ascii('D'))\r\n```\r\n\r\nI think this may be incorrect because as far as I can tell ``replace`` is not an in-place operation for ``chararray`` (it returns a copy). Commenting out this code doesn't cause any tests to fail so I think this code isn't being tested anyway.\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/io/fits/fitsrec.py ###\n```python\n# Licensed under a 3-clause BSD style license - see PYFITS.rst\n\n\n\nclass FITS_record:\n\n    def __init__(self, input, row=0, start=None, end=None, step=None,\n                 base=None, **kwargs):\n...\n\n    def __getitem__(self, key):\n...\n\n    def __setitem__(self, key, value):\n...\n\n    def __len__(self):\n...\n\n    def __repr__(self):\n...\n\n    def field(self, field):\n...\n\n    def setfield(self, field, value):\n...\n\n    @lazyproperty\n    def _bases(self):\n...\n\n    def _get_index(self, indx):\n...\n\n\nclass FITS_rec(np.recarray):\n\n    _record_type = FITS_record\n    _character_as_bytes = False\n\n    def __new__(subtype, input):\n...\n\n    def __setstate__(self, state):\n...\n\n    def __reduce__(self):\n...\n\n    def __array_finalize__(self, obj):\n...\n\n    def _init(self):\n...\n\n    @classmethod\n    def from_columns(cls, columns, nrows=0, fill=False, character_as_bytes=False):\n...\n\n    def __repr__(self):\n...\n\n    def __getitem__(self, key):\n...\n\n    def __setitem__(self, key, value):\n...\n\n    def copy(self, order='C'):\n...\n\n    @property\n    def columns(self):\n...\n\n    @property\n    def _coldefs(self):\n...\n\n    @_coldefs.setter\n    def _coldefs(self, cols):\n...\n\n    @_coldefs.deleter\n    def _coldefs(self):\n...\n\n    def __del__(self):\n...\n\n    @property\n    def names(self):\n...\n\n    @property\n    def formats(self):\n...\n\n    @property\n    def _raw_itemsize(self):\n...\n\n    def field(self, key):\n...\n\n    def _cache_field(self, name, field):\n...\n\n    def _update_column_attribute_changed(self, column, idx, attr, old_value,\n                                         new_value):\n...\n\n    def _update_column_name(self, column, idx, old_name, name):\n...\n\n    def _convert_x(self, field, recformat):\n...\n\n    def _convert_p(self, column, field, recformat):\n...\n\n    def _convert_ascii(self, column, field):\n...\n\n    def _convert_other(self, column, field, recformat):\n...\n\n    def _get_heap_data(self):\n...\n\n    def _get_raw_data(self):\n...\n\n    def _get_scale_factors(self, column):\n...\n\n    def _scale_back(self, update_heap_pointers=True):\n...\n\n    def _scale_back_strings(self, col_idx, input_field, output_field):\n...\n\n    def _scale_back_ascii(self, col_idx, input_field, output_field):\n...\n\n\ndef _get_recarray_field(array, key):\n...\n\n\nclass _UnicodeArrayEncodeError(UnicodeEncodeError):\n    def __init__(self, encoding, object_, start, end, reason, index):\n...\n\n\ndef _ascii_encode(inarray, out=None):\n...\n\n\ndef _has_unicode_fields(array):\n...\n\n```\n\n### File: astropy/io/fits/column.py ###\n```python\n# Licensed under a 3-clause BSD style license - see PYFITS.rst\n\n\n__all__ = ['Column', 'ColDefs', 'Delayed']\n\n\n# mapping from TFORM data type to numpy data type (code)\n# L: Logical (Boolean)\n# B: Unsigned Byte\n# I: 16-bit Integer\n# J: 32-bit Integer\n# K: 64-bit Integer\n# E: Single-precision Floating Point\n# D: Double-precision Floating Point\n# C: Single-precision Complex\n# M: Double-precision Complex\n# A: Character\nFITS2NUMPY = {'L': 'i1', 'B': 'u1', 'I': 'i2', 'J': 'i4', 'K': 'i8', 'E': 'f4',\n              'D': 'f8', 'C': 'c8', 'M': 'c16', 'A': 'a'}\n\n# the inverse dictionary of the above\nNUMPY2FITS = {val: key for key, val in FITS2NUMPY.items()}\n# Normally booleans are represented as ints in Astropy, but if passed in a numpy\n# boolean array, that should be supported\nNUMPY2FITS['b1'] = 'L'\n# Add unsigned types, which will be stored as signed ints with a TZERO card.\nNUMPY2FITS['u2'] = 'I'\nNUMPY2FITS['u4'] = 'J'\nNUMPY2FITS['u8'] = 'K'\n# Add half precision floating point numbers which will be up-converted to\n# single precision.\nNUMPY2FITS['f2'] = 'E'\n\n# This is the order in which values are converted to FITS types\n# Note that only double precision floating point/complex are supported\nFORMATORDER = ['L', 'B', 'I', 'J', 'K', 'D', 'M', 'A']\n\n# Convert single precision floating point/complex to double precision.\nFITSUPCONVERTERS = {'E': 'D', 'C': 'M'}\n\n# mapping from ASCII table TFORM data type to numpy data type\n# A: Character\n# I: Integer (32-bit)\n# J: Integer (64-bit; non-standard)\n# F: Float (64-bit; fixed decimal notation)\n# E: Float (64-bit; exponential notation)\n# D: Float (64-bit; exponential notation, always 64-bit by convention)\nASCII2NUMPY = {'A': 'a', 'I': 'i4', 'J': 'i8', 'F': 'f8', 'E': 'f8', 'D': 'f8'}\n\n# Maps FITS ASCII column format codes to the appropriate Python string\n# formatting codes for that type.\nASCII2STR = {'A': '', 'I': 'd', 'J': 'd', 'F': 'f', 'E': 'E', 'D': 'E'}\n\n# For each ASCII table format code, provides a default width (and decimal\n# precision) for when one isn't given explicitly in the column format\nASCII_DEFAULT_WIDTHS = {'A': (1, 0), 'I': (10, 0), 'J': (15, 0),\n                        'E': (15, 7), 'F': (16, 7), 'D': (25, 17)}\n\n\n# tuple of column/field definition common names and keyword names, make\n# sure to preserve the one-to-one correspondence when updating the list(s).\n# Use lists, instead of dictionaries so the names can be displayed in a\n# preferred order.\nKEYWORD_NAMES = ('TTYPE', 'TFORM', 'TUNIT', 'TNULL', 'TSCAL', 'TZERO',\n                 'TDISP', 'TBCOL', 'TDIM', 'TCTYP', 'TCUNI', 'TCRPX',\n                 'TCRVL', 'TCDLT', 'TRPOS')\nKEYWORD_ATTRIBUTES = ('name', 'format', 'unit', 'null', 'bscale', 'bzero',\n                      'disp', 'start', 'dim', 'coord_type', 'coord_unit',\n                      'coord_ref_point', 'coord_ref_value', 'coord_inc',\n                      'time_ref_pos')\n\n\nKEYWORD_TO_ATTRIBUTE = OrderedDict(zip(KEYWORD_NAMES, KEYWORD_ATTRIBUTES))\n\nATTRIBUTE_TO_KEYWORD = OrderedDict(zip(KEYWORD_ATTRIBUTES, KEYWORD_NAMES))\n\n\n# TODO: Define a list of default comments to associate with each table keyword\n\n# TFORMn regular expression\nTFORMAT_RE = re.compile(r'(?P<repeat>^[0-9]*)(?P<format>[LXBIJKAEDCMPQ])'\n                        r'(?P<option>[!-~]*)', re.I)\n\n# TFORMn for ASCII tables; two different versions depending on whether\n# the format is floating-point or not; allows empty values for width\n# in which case defaults are used\nTFORMAT_ASCII_RE = re.compile(r'(?:(?P<format>[AIJ])(?P<width>[0-9]+)?)|'\n                              r'(?:(?P<formatf>[FED])'\n                              r'(?:(?P<widthf>[0-9]+)\\.'\n                              r'(?P<precision>[0-9]+))?)')\n\nTTYPE_RE = re.compile(r'[0-9a-zA-Z_]+')\n\n# table definition keyword regular expression\nTDEF_RE = re.compile(r'(?P<label>^T[A-Z]*)(?P<num>[1-9][0-9 ]*$)')\n\n# table dimension keyword regular expression (fairly flexible with whitespace)\nTDIM_RE = re.compile(r'\\(\\s*(?P<dims>(?:\\d+,\\s*)+\\s*\\d+)\\s*\\)\\s*')\n\n# value for ASCII table cell with value = TNULL\n# this can be reset by user.\nASCIITNULL = 0\n\n# The default placeholder to use for NULL values in ASCII tables when\n# converting from binary to ASCII tables\nDEFAULT_ASCII_TNULL = '---'\n\n\nclass Delayed:\n\n    def __init__(self, hdu=None, field=None):\n...\n\n    def __getitem__(self, key):\n...\n\n\nclass _BaseColumnFormat(str):\n\n    def __eq__(self, other):\n...\n\n    def __hash__(self):\n...\n\n    @lazyproperty\n    def dtype(self):\n...\n\n    @classmethod\n    def from_column_format(cls, format):\n...\n\n\nclass _ColumnFormat(_BaseColumnFormat):\n\n    def __new__(cls, format):\n...\n\n    @classmethod\n    def from_recformat(cls, recformat):\n...\n\n    @lazyproperty\n    def recformat(self):\n...\n\n    @lazyproperty\n    def canonical(self):\n...\n\n\nclass _AsciiColumnFormat(_BaseColumnFormat):\n\n    def __new__(cls, format, strict=False):\n...\n\n    @classmethod\n    def from_column_format(cls, format):\n...\n\n    @classmethod\n    def from_recformat(cls, recformat):\n...\n\n    @lazyproperty\n    def recformat(self):\n...\n\n    @lazyproperty\n    def canonical(self):\n...\n\n\nclass _FormatX(str):\n\n    def __new__(cls, repeat=1):\n...\n\n    def __getnewargs__(self):\n...\n\n    @property\n    def tform(self):\n...\n\n\n# TODO: Table column formats need to be verified upon first reading the file;\n# as it is, an invalid P format will raise a VerifyError from some deep,\n# unexpected place\nclass _FormatP(str):\n\n    # As far as I can tell from my reading of the FITS standard, a type code is\n    # *required* for P and Q formats; there is no default\n    _format_re_template = (r'(?P<repeat>\\d+)?{}(?P<dtype>[LXBIJKAEDCM])'\n                           r'(?:\\((?P<max>\\d*)\\))?')\n    _format_code = 'P'\n    _format_re = re.compile(_format_re_template.format(_format_code))\n    _descriptor_format = '2i4'\n\n    def __new__(cls, dtype, repeat=None, max=None):\n...\n\n    def __getnewargs__(self):\n...\n\n    @classmethod\n    def from_tform(cls, format):\n...\n\n    @property\n    def tform(self):\n...\n\n\nclass _FormatQ(_FormatP):\n\n    _format_code = 'Q'\n    _format_re = re.compile(_FormatP._format_re_template.format(_format_code))\n    _descriptor_format = '2i8'\n\n\nclass ColumnAttribute:\n\n    def __init__(self, keyword):\n...\n\n    def __get__(self, obj, objtype=None):\n...\n\n    def __set__(self, obj, value):\n...\n\n    def __call__(self, func):\n...\n\n    def __repr__(self):\n...\n\n\nclass Column(NotifierMixin):\n\n    def __init__(self, name=None, format=None, unit=None, null=None,\n                 bscale=None, bzero=None, disp=None, start=None, dim=None,\n                 array=None, ascii=None, coord_type=None, coord_unit=None,\n                 coord_ref_point=None, coord_ref_value=None, coord_inc=None,\n                 time_ref_pos=None):\n...\n\n    def __repr__(self):\n...\n\n    def __eq__(self, other):\n...\n\n    def __hash__(self):\n...\n\n    @property\n    def array(self):\n...\n\n    @array.setter\n    def array(self, array):\n...\n\n    @array.deleter\n    def array(self):\n...\n\n    @ColumnAttribute('TTYPE')\n    def name(col, name):\n...\n\n    @ColumnAttribute('TCTYP')\n    def coord_type(col, coord_type):\n...\n\n    @ColumnAttribute('TCUNI')\n    def coord_unit(col, coord_unit):\n...\n\n    @ColumnAttribute('TCRPX')\n    def coord_ref_point(col, coord_ref_point):\n...\n\n    @ColumnAttribute('TCRVL')\n    def coord_ref_value(col, coord_ref_value):\n...\n\n    @ColumnAttribute('TCDLT')\n    def coord_inc(col, coord_inc):\n...\n\n    @ColumnAttribute('TRPOS')\n    def time_ref_pos(col, time_ref_pos):\n...\n\n    format = ColumnAttribute('TFORM')\n    unit = ColumnAttribute('TUNIT')\n    null = ColumnAttribute('TNULL')\n    bscale = ColumnAttribute('TSCAL')\n    bzero = ColumnAttribute('TZERO')\n    disp = ColumnAttribute('TDISP')\n    start = ColumnAttribute('TBCOL')\n    dim = ColumnAttribute('TDIM')\n\n    @lazyproperty\n    def ascii(self):\n...\n\n    @lazyproperty\n    def dtype(self):\n...\n\n    def copy(self):\n...\n\n    @staticmethod\n    def _convert_format(format, cls):\n...\n\n    @classmethod\n    def _verify_keywords(cls, name=None, format=None, unit=None, null=None,\n                         bscale=None, bzero=None, disp=None, start=None,\n                         dim=None, ascii=None, coord_type=None, coord_unit=None,\n                         coord_ref_point=None, coord_ref_value=None,\n                         coord_inc=None, time_ref_pos=None):\n...\n\n    @classmethod\n    def _determine_formats(cls, format, start, dim, ascii):\n...\n\n    @classmethod\n    def _guess_format(cls, format, start, dim):\n...\n\n    def _convert_to_valid_data_type(self, array):\n...\n\n\nclass ColDefs(NotifierMixin):\n\n    _padding_byte = '\\x00'\n    _col_format_cls = _ColumnFormat\n\n    def __new__(cls, input, ascii=False):\n...\n\n    def __getnewargs__(self):\n...\n\n    def __init__(self, input, ascii=False):\n...\n\n    def _init_from_coldefs(self, coldefs):\n...\n\n    def _init_from_sequence(self, columns):\n...\n\n    def _init_from_array(self, array):\n...\n\n    def _init_from_table(self, table):\n...\n\n    def __copy__(self):\n...\n\n    def __deepcopy__(self, memo):\n...\n\n    def _copy_column(self, column):\n...\n\n    def __getattr__(self, name):\n...\n\n    @lazyproperty\n    def dtype(self):\n...\n\n    @lazyproperty\n    def names(self):\n...\n\n    @lazyproperty\n    def formats(self):\n...\n\n    @lazyproperty\n    def _arrays(self):\n...\n\n    @lazyproperty\n    def _recformats(self):\n...\n\n    @lazyproperty\n    def _dims(self):\n...\n\n    def __getitem__(self, key):\n...\n\n    def __len__(self):\n...\n\n    def __repr__(self):\n...\n\n    def __add__(self, other, option='left'):\n...\n\n    def __radd__(self, other):\n...\n\n    def __sub__(self, other):\n...\n\n    def _update_column_attribute_changed(self, column, attr, old_value,\n                                         new_value):\n...\n\n    def add_col(self, column):\n...\n\n    def del_col(self, col_name):\n...\n\n    def change_attrib(self, col_name, attrib, new_value):\n...\n\n    def change_name(self, col_name, new_name):\n...\n\n    def change_unit(self, col_name, new_unit):\n...\n\n    def info(self, attrib='all', output=None):\n...\n\n\nclass _AsciiColDefs(ColDefs):\n\n    _padding_byte = ' '\n    _col_format_cls = _AsciiColumnFormat\n\n    def __init__(self, input, ascii=True):\n...\n\n    @lazyproperty\n    def dtype(self):\n...\n\n    @property\n    def spans(self):\n...\n\n    @lazyproperty\n    def _recformats(self):\n...\n\n    def add_col(self, column):\n...\n\n    def del_col(self, col_name):\n...\n\n    def _update_field_metrics(self):\n...\n\n\n# Utilities\n\n\nclass _VLF(np.ndarray):\n\n    def __new__(cls, input, dtype='a'):\n...\n\n    def __array_finalize__(self, obj):\n...\n\n    def __setitem__(self, key, value):\n...\n\n\ndef _get_index(names, key):\n...\n\n\ndef _unwrapx(input, output, repeat):\n...\n\n\ndef _wrapx(input, output, repeat):\n...\n\n\ndef _makep(array, descr_output, format, nrows=None):\n...\n\n\ndef _parse_tformat(tform):\n...\n\n\ndef _parse_ascii_tformat(tform, strict=False):\n...\n\n\ndef _parse_tdim(tdim):\n...\n\n\ndef _scalar_to_format(value):\n...\n\n\ndef _cmp_recformats(f1, f2):\n...\n\n\ndef _convert_fits2record(format):\n...\n\n\ndef _convert_record2fits(format):\n...\n\n\ndef _dtype_to_recformat(dtype):\n...\n\n\ndef _convert_format(format, reverse=False):\n...\n\n\ndef _convert_ascii_format(format, reverse=False):\n...\n\n```\n\n### File: astropy/io/fits/util.py ###\n```python\n# Licensed under a 3-clause BSD style license - see PYFITS.rst\n\n\n\ncmp = lambda a, b: (a > b) - (a < b)\n\nall_integer_types = (int, np.integer)\n\n\nclass NotifierMixin:\n\n    _listeners = None\n\n    def _add_listener(self, listener):\n...\n\n    def _remove_listener(self, listener):\n...\n\n    def _notify(self, notification, *args, **kwargs):\n...\n\n    def __getstate__(self):\n...\n\n\ndef first(iterable):\n...\n\n\ndef itersubclasses(cls, _seen=None):\n...\n\n\ndef ignore_sigint(func):\n...\n\n\ndef pairwise(iterable):\n...\n\n\ndef encode_ascii(s):\n...\n\n\ndef decode_ascii(s):\n...\n\n\ndef isreadable(f):\n...\n\n\ndef iswritable(f):\n...\n\n\ndef isfile(f):\n...\n\n\ndef fileobj_open(filename, mode):\n...\n\n\ndef fileobj_name(f):\n...\n\n\ndef fileobj_closed(f):\n...\n\n\ndef fileobj_mode(f):\n...\n\n\ndef _fileobj_normalize_mode(f):\n...\n\n\ndef fileobj_is_binary(f):\n...\n\n\ndef translate(s, table, deletechars):\n...\n\n\ndef fill(text, width, **kwargs):\n...\n\n\n# On MacOS X 10.8 and earlier, there is a bug that causes numpy.fromfile to\n# fail when reading over 2Gb of data. If we detect these versions of MacOS X,\n# we can instead read the data in chunks. To avoid performance penalties at\n# import time, we defer the setting of this global variable until the first\n# time it is needed.\nCHUNKED_FROMFILE = None\n\n\ndef _array_from_file(infile, dtype, count):\n...\n\n\n_OSX_WRITE_LIMIT = (2 ** 32) - 1\n_WIN_WRITE_LIMIT = (2 ** 31) - 1\n\n\ndef _array_to_file(arr, outfile):\n...\n\n\ndef _array_to_file_like(arr, fileobj):\n...\n\n\ndef _write_string(f, s):\n...\n\n\ndef _convert_array(array, dtype):\n...\n\n\ndef _unsigned_zero(dtype):\n...\n\n\ndef _is_pseudo_unsigned(dtype):\n...\n\n\ndef _is_int(val):\n...\n\n\ndef _str_to_num(val):\n...\n\n\ndef _words_group(input, strlen):\n...\n\n\ndef _tmp_name(input):\n...\n\n\ndef _get_array_mmap(array):\n...\n\n\n@contextmanager\ndef _free_space_check(hdulist, dirname=None):\n...\n\n\ndef _extract_number(value, default):\n...\n\n\ndef get_testdata_filepath(filename):\n...\n\n\ndef _rstrip_inplace(array):\n...\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "astropy__astropy-7746", "found_files": ["astropy/wcs/wcs.py", "astropy/wcs/utils.py", "astropy/wcs/docstrings.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/wcs/wcs.py": ["function: WCS.wcs_pix2world\nfunction: WCS._array_converter\nfunction: WCS._return_list_of_arrays"], "astropy/wcs/utils.py": [""], "astropy/wcs/docstrings.py": [""]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/wcs/wcs.py\nfunction: WCS.wcs_pix2world\nfunction: WCS._array_converter\nfunction: WCS._return_list_of_arrays\n```"}], "related_loc_traj": [{"response": "```\nastropy/wcs/wcs.py\nfunction: WCS.wcs_pix2world\nfunction: WCS._array_converter\nfunction: WCS._return_list_of_arrays\n```", "usage": {"completion_tokens": 40, "prompt_tokens": 15316}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nIssue when passing empty lists/arrays to WCS transformations\nThe following should not fail but instead should return empty lists/arrays:\r\n\r\n```\r\nIn [1]: from astropy.wcs import WCS\r\n\r\nIn [2]: wcs = WCS('2MASS_h.fits')\r\n\r\nIn [3]: wcs.wcs_pix2world([], [], 0)\r\n---------------------------------------------------------------------------\r\nInconsistentAxisTypesError                Traceback (most recent call last)\r\n<ipython-input-3-e2cc0e97941a> in <module>()\r\n----> 1 wcs.wcs_pix2world([], [], 0)\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in wcs_pix2world(self, *args, **kwargs)\r\n   1352         return self._array_converter(\r\n   1353             lambda xy, o: self.wcs.p2s(xy, o)['world'],\r\n-> 1354             'output', *args, **kwargs)\r\n   1355     wcs_pix2world.__doc__ = \"\"\"\r\n   1356         Transforms pixel coordinates to world coordinates by doing\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1267                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1268 \r\n-> 1269             return _return_list_of_arrays(axes, origin)\r\n   1270 \r\n   1271         raise TypeError(\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1223             if ra_dec_order and sky == 'input':\r\n   1224                 xy = self._denormalize_sky(xy)\r\n-> 1225             output = func(xy, origin)\r\n   1226             if ra_dec_order and sky == 'output':\r\n   1227                 output = self._normalize_sky(output)\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in <lambda>(xy, o)\r\n   1351             raise ValueError(\"No basic WCS settings were created.\")\r\n   1352         return self._array_converter(\r\n-> 1353             lambda xy, o: self.wcs.p2s(xy, o)['world'],\r\n   1354             'output', *args, **kwargs)\r\n   1355     wcs_pix2world.__doc__ = \"\"\"\r\n\r\nInconsistentAxisTypesError: ERROR 4 in wcsp2s() at line 2646 of file cextern/wcslib/C/wcs.c:\r\nncoord and/or nelem inconsistent with the wcsprm.\r\n```\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/wcs/wcs.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n__all__ = ['FITSFixedWarning', 'WCS', 'find_all_wcs',\n           'DistortionLookupTable', 'Sip', 'Tabprm', 'Wcsprm',\n           'WCSBase', 'validate', 'WcsError', 'SingularMatrixError',\n           'InconsistentAxisTypesError', 'InvalidTransformError',\n           'InvalidCoordinateError', 'NoSolutionError',\n           'InvalidSubimageSpecificationError', 'NoConvergence',\n           'NonseparableSubimageCoordinateSystemError',\n           'NoWcsKeywordsFoundError', 'InvalidTabularParametersError']\n\n\n__doctest_skip__ = ['WCS.all_world2pix']\n\n\n# Additional relax bit flags\nWCSHDO_SIP = 0x80000\n\n# Regular expression defining SIP keyword It matches keyword that starts with A\n# or B, optionally followed by P, followed by an underscore then a number in\n# range of 0-19, followed by an underscore and another number in range of 0-19.\n# Keyword optionally ends with a capital letter.\nSIP_KW = re.compile('''^[AB]P?_1?[0-9]_1?[0-9][A-Z]?$''')\n\n\ndef _parse_keysel(keysel):\n...\n\n\nclass NoConvergence(Exception):\n\n    def __init__(self, *args, best_solution=None, accuracy=None, niter=None,\n                 divergent=None, slow_conv=None, **kwargs):\n...\n\n\nclass FITSFixedWarning(AstropyWarning):\n    pass\n\n\nclass WCS(WCSBase):\n\n    def __init__(self, header=None, fobj=None, key=' ', minerr=0.0,\n                 relax=True, naxis=None, keysel=None, colsel=None,\n                 fix=True, translate_units='', _do_set=True):\n...\n\n    def __copy__(self):\n...\n\n    def __deepcopy__(self, memo):\n...\n\n    def copy(self):\n...\n\n    def deepcopy(self):\n...\n\n    def sub(self, axes=None):\n...\n    if _wcs is not None:\n        sub.__doc__ = _wcs.Wcsprm.sub.__doc__\n\n    def _fix_scamp(self):\n...\n\n    def fix(self, translate_units='', naxis=None):\n...\n\n    def calc_footprint(self, header=None, undistort=True, axes=None, center=True):\n...\n\n    def _read_det2im_kw(self, header, fobj, err=0.0):\n...\n\n    def _read_d2im_old_format(self, header, fobj, axiscorr):\n...\n\n    def _write_det2im(self, hdulist):\n...\n\n    def _read_distortion_kw(self, header, fobj, dist='CPDIS', err=0.0):\n...\n\n    def _write_distortion_kw(self, hdulist, dist='CPDIS'):\n...\n\n    def _remove_sip_kw(self, header):\n...\n\n    def _read_sip_kw(self, header, wcskey=\"\"):\n...\n\n    def _write_sip_kw(self):\n...\n\n    def _denormalize_sky(self, sky):\n...\n\n    def _normalize_sky(self, sky):\n...\n\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n...\n\n    def all_pix2world(self, *args, **kwargs):\n...\n    all_pix2world.__doc__ = \"\"\"\n        Transforms pixel coordinates to world coordinates.\n\n        Performs all of the following in series:\n\n            - Detector to image plane correction (if present in the\n              FITS file)\n\n            - `SIP`_ distortion correction (if present in the FITS\n              file)\n...\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('naxis', 8),\n                   __.RA_DEC_ORDER(8),\n                   __.RETURNS('sky coordinates, in degrees', 8))\n\n    def wcs_pix2world(self, *args, **kwargs):\n...\n    wcs_pix2world.__doc__ = \"\"\"\n        Transforms pixel coordinates to world coordinates by doing\n        only the basic `wcslib`_ transformation.\n\n        No `SIP`_ or `distortion paper`_ table lookup correction is\n        applied.  To perform distortion correction, see\n        `~astropy.wcs.WCS.all_pix2world`,\n        `~astropy.wcs.WCS.sip_pix2foc`, `~astropy.wcs.WCS.p4_pix2foc`,\n        or `~astropy.wcs.WCS.pix2foc`.\n\n...\n        The order of the axes for the result is determined by the\n        ``CTYPEia`` keywords in the FITS header, therefore it may not\n        always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp` and `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        \"\"\".format(__.TWO_OR_MORE_ARGS('naxis', 8),\n                   __.RA_DEC_ORDER(8),\n                   __.RETURNS('world coordinates, in degrees', 8))\n\n    def _all_world2pix(self, world, origin, tolerance, maxiter, adaptive,\n                       detect_divergence, quiet):\n...\n\n    def all_world2pix(self, *args, tolerance=1e-4, maxiter=20, adaptive=False,\n                      detect_divergence=True, quiet=False, **kwargs):\n...\n\n    all_world2pix.__doc__ = \"\"\"\n        all_world2pix(*arg, accuracy=1.0e-4, maxiter=20,\n        adaptive=False, detect_divergence=True, quiet=False)\n\n        Transforms world coordinates to pixel coordinates, using\n        numerical iteration to invert the full forward transformation\n        `~astropy.wcs.WCS.all_pix2world` with complete\n        distortion model.\n\n\n...\n        >>> raise e\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy.  After 6 iterations, the solution is\n        diverging at least for one input point.\n\n        \"\"\".format(__.TWO_OR_MORE_ARGS('naxis', 8),\n                   __.RA_DEC_ORDER(8),\n                   __.RETURNS('pixel coordinates', 8))\n\n    def wcs_world2pix(self, *args, **kwargs):\n...\n    wcs_world2pix.__doc__ = \"\"\"\n        Transforms world coordinates to pixel coordinates, using only\n        the basic `wcslib`_ WCS transformation.  No `SIP`_ or\n        `distortion paper`_ table lookup transformation is applied.\n\n        Parameters\n        ----------\n        {0}\n\n            For a transformation that is not two-dimensional, the\n...\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('naxis', 8),\n                   __.RA_DEC_ORDER(8),\n                   __.RETURNS('pixel coordinates', 8))\n\n    def pix2foc(self, *args):\n...\n    pix2foc.__doc__ = \"\"\"\n        Convert pixel coordinates to focal plane coordinates using the\n        `SIP`_ polynomial distortion convention and `distortion\n        paper`_ table-lookup correction.\n\n        The output is in absolute pixel coordinates, not relative to\n        ``CRPIX``.\n\n        Parameters\n        ----------\n\n        {0}\n\n        Returns\n        -------\n\n        {1}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('2', 8),\n                   __.RETURNS('focal coordinates', 8))\n\n    def p4_pix2foc(self, *args):\n...\n    p4_pix2foc.__doc__ = \"\"\"\n        Convert pixel coordinates to focal plane coordinates using\n        `distortion paper`_ table-lookup correction.\n\n        The output is in absolute pixel coordinates, not relative to\n        ``CRPIX``.\n\n        Parameters\n        ----------\n\n        {0}\n\n        Returns\n        -------\n\n        {1}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('2', 8),\n                   __.RETURNS('focal coordinates', 8))\n\n    def det2im(self, *args):\n...\n    det2im.__doc__ = \"\"\"\n        Convert detector coordinates to image plane coordinates using\n        `distortion paper`_ table-lookup correction.\n\n        The output is in absolute pixel coordinates, not relative to\n        ``CRPIX``.\n\n        Parameters\n        ----------\n\n        {0}\n\n        Returns\n        -------\n\n        {1}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('2', 8),\n                   __.RETURNS('pixel coordinates', 8))\n\n    def sip_pix2foc(self, *args):\n...\n    sip_pix2foc.__doc__ = \"\"\"\n        Convert pixel coordinates to focal plane coordinates using the\n        `SIP`_ polynomial distortion convention.\n\n        The output is in pixel coordinates, relative to ``CRPIX``.\n\n        FITS WCS `distortion paper`_ table lookup correction is not\n        applied, even if that information existed in the FITS file\n        that initialized this :class:`~astropy.wcs.WCS` object.  To\n        correct for that, use `~astropy.wcs.WCS.pix2foc` or\n        `~astropy.wcs.WCS.p4_pix2foc`.\n\n        Parameters\n        ----------\n\n        {0}\n\n        Returns\n        -------\n\n        {1}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('2', 8),\n                   __.RETURNS('focal coordinates', 8))\n\n    def sip_foc2pix(self, *args):\n...\n    sip_foc2pix.__doc__ = \"\"\"\n        Convert focal plane coordinates to pixel coordinates using the\n        `SIP`_ polynomial distortion convention.\n\n        FITS WCS `distortion paper`_ table lookup distortion\n        correction is not applied, even if that information existed in\n        the FITS file that initialized this `~astropy.wcs.WCS` object.\n\n        Parameters\n        ----------\n\n        {0}\n\n        Returns\n        -------\n\n        {1}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\".format(__.TWO_OR_MORE_ARGS('2', 8),\n                   __.RETURNS('pixel coordinates', 8))\n\n    def to_fits(self, relax=False, key=None):\n...\n\n    def to_header(self, relax=None, key=None):\n...\n\n    def _fix_ctype(self, header, add_sip=True, log_message=True):\n...\n\n    def to_header_string(self, relax=None):\n...\n\n    def footprint_to_file(self, filename='footprint.reg', color='green',\n                          width=2, coordsys=None):\n...\n\n    @property\n    def _naxis1(self):\n...\n\n    @_naxis1.setter\n    def _naxis1(self, value):\n...\n\n    @property\n    def _naxis2(self):\n...\n\n    @_naxis2.setter\n    def _naxis2(self, value):\n...\n\n    def _get_naxis(self, header=None):\n...\n\n    def printwcs(self):\n...\n\n    def __repr__(self):\n...\n\n    def get_axis_types(self):\n...\n\n    def __reduce__(self):\n...\n\n    def dropaxis(self, dropax):\n...\n\n    def swapaxes(self, ax0, ax1):\n...\n\n    def reorient_celestial_first(self):\n...\n\n    def slice(self, view, numpy_order=True):\n...\n\n    def __getitem__(self, item):\n...\n\n    def __iter__(self):\n...\n\n    @property\n    def axis_type_names(self):\n...\n\n    @property\n    def celestial(self):\n...\n\n    @property\n    def is_celestial(self):\n...\n\n    @property\n    def has_celestial(self):\n...\n\n    @property\n    def pixel_scale_matrix(self):\n...\n\n    def _as_mpl_axes(self):\n...\n\n\ndef __WCS_unpickle__(cls, dct, fits_data):\n...\n\n\ndef find_all_wcs(header, relax=True, keysel=None, fix=True,\n                 translate_units='',\n                 _do_set=True):\n...\n\n\ndef validate(source):\n...\n\n```\n\n### File: astropy/wcs/utils.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__doctest_skip__ = ['wcs_to_celestial_frame', 'celestial_frame_to_wcs']\n\n__all__ = ['add_stokes_axis_to_wcs', 'celestial_frame_to_wcs',\n           'wcs_to_celestial_frame', 'proj_plane_pixel_scales',\n           'proj_plane_pixel_area', 'is_proj_plane_distorted',\n           'non_celestial_pixel_scales', 'skycoord_to_pixel',\n           'pixel_to_skycoord', 'custom_wcs_to_frame_mappings',\n           'custom_frame_to_wcs_mappings']\n\n\ndef add_stokes_axis_to_wcs(wcs, add_before_ind):\n...\n\n\ndef _wcs_to_celestial_frame_builtin(wcs):\n...\n\n\ndef _celestial_frame_to_wcs_builtin(frame, projection='TAN'):\n...\n\n\nWCS_FRAME_MAPPINGS = [[_wcs_to_celestial_frame_builtin]]\nFRAME_WCS_MAPPINGS = [[_celestial_frame_to_wcs_builtin]]\n\n\nclass custom_wcs_to_frame_mappings:\n    def __init__(self, mappings=[]):\n...\n\n    def __enter__(self):\n...\n\n    def __exit__(self, type, value, tb):\n...\n\n\n# Backward-compatibility\ncustom_frame_mappings = custom_wcs_to_frame_mappings\n\n\nclass custom_frame_to_wcs_mappings:\n    def __init__(self, mappings=[]):\n...\n\n    def __enter__(self):\n...\n\n    def __exit__(self, type, value, tb):\n...\n\n\ndef wcs_to_celestial_frame(wcs):\n...\n\n\ndef celestial_frame_to_wcs(frame, projection='TAN'):\n...\n\n\ndef proj_plane_pixel_scales(wcs):\n...\n\n\ndef proj_plane_pixel_area(wcs):\n...\n\n\ndef is_proj_plane_distorted(wcs, maxerr=1.0e-5):\n...\n\n\ndef _is_cd_orthogonal(cd, maxerr):\n...\n\n\ndef non_celestial_pixel_scales(inwcs):\n...\n\n\ndef _has_distortion(wcs):\n...\n\n\n# TODO: in future, we should think about how the following two functions can be\n# integrated better into the WCS class.\n\ndef skycoord_to_pixel(coords, wcs, origin=0, mode='all'):\n...\n\n\ndef pixel_to_skycoord(xp, yp, wcs, origin=0, mode='all', cls=None):\n...\n\n```\n\n### File: astropy/wcs/docstrings.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# It gets to be really tedious to type long docstrings in ANSI C\n# syntax (since multi-line string literals are not valid).\n# Therefore, the docstrings are written here in doc/docstrings.py,\n# which are then converted by setup.py into docstrings.h, which is\n# included by pywcs.c\n\n\na = \"\"\"\n``double array[a_order+1][a_order+1]`` Focal plane transformation\nmatrix.\n\nThe `SIP`_ ``A_i_j`` matrix used for pixel to focal plane\ntransformation.\n\nIts values may be changed in place, but it may not be resized, without\ncreating a new `~astropy.wcs.Sip` object.\n\"\"\"\n\na_order = \"\"\"\n``int`` (read-only) Order of the polynomial (``A_ORDER``).\n\"\"\"\n\nall_pix2world = \"\"\"\nall_pix2world(pixcrd, origin) -> ``double array[ncoord][nelem]``\n\nTransforms pixel coordinates to world coordinates.\n\nDoes the following:\n\n    - Detector to image plane correction (if present)\n\n    - SIP distortion correction (if present)\n...\n\nValueError\n    x- and y-coordinate arrays are not the same size.\n\nInvalidTransformError\n    Invalid coordinate transformation.\n\nInvalidTransformError\n    Ill-conditioned coordinate transformation parameters.\n\"\"\".format(__.ORIGIN())\n\nalt = \"\"\"\n``str`` Character code for alternate coordinate descriptions.\n\nFor example, the ``\"a\"`` in keyword names such as ``CTYPEia``.  This\nis a space character for the primary coordinate description, or one of\nthe 26 upper-case letters, A-Z.\n\"\"\"\n\nap = \"\"\"\n``double array[ap_order+1][ap_order+1]`` Focal plane to pixel\ntransformation matrix.\n\nThe `SIP`_ ``AP_i_j`` matrix used for focal plane to pixel\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~astropy.wcs.Sip` object.\n\"\"\"\n\nap_order = \"\"\"\n``int`` (read-only) Order of the polynomial (``AP_ORDER``).\n\"\"\"\n\naxis_types = \"\"\"\n``int array[naxis]`` An array of four-digit type codes for each axis.\n\n- First digit (i.e. 1000s):\n\n  - 0: Non-specific coordinate type.\n\n  - 1: Stokes coordinate.\n\n  - 2: Celestial coordinate (including ``CUBEFACE``).\n...\n\n    - 1: Latitude coordinate.\n\n    - 2: ``CUBEFACE`` number.\n\n  - For lookup tables: the axis number in a multidimensional table.\n\n``CTYPEia`` in ``\"4-3\"`` form with unrecognized algorithm code will\nhave its type set to -1 and generate an error.\n\"\"\"\n\nb = \"\"\"\n``double array[b_order+1][b_order+1]`` Pixel to focal plane\ntransformation matrix.\n\nThe `SIP`_ ``B_i_j`` matrix used for pixel to focal plane\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~astropy.wcs.Sip` object.\n\"\"\"\n\nb_order = \"\"\"\n``int`` (read-only) Order of the polynomial (``B_ORDER``).\n\"\"\"\n\nbounds_check = \"\"\"\nbounds_check(pix2world, world2pix)\n\nEnable/disable bounds checking.\n\nParameters\n----------\npix2world : bool, optional\n    When `True`, enable bounds checking for the pixel-to-world (p2x)\n    transformations.  Default is `True`.\n\nworld2pix : bool, optional\n    When `True`, enable bounds checking for the world-to-pixel (s2x)\n    transformations.  Default is `True`.\n\nNotes\n-----\nNote that by default (without calling `bounds_check`) strict bounds\nchecking is enabled.\n\"\"\"\n\nbp = \"\"\"\n``double array[bp_order+1][bp_order+1]`` Focal plane to pixel\ntransformation matrix.\n\nThe `SIP`_ ``BP_i_j`` matrix used for focal plane to pixel\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~astropy.wcs.Sip` object.\n\"\"\"\n\nbp_order = \"\"\"\n``int`` (read-only) Order of the polynomial (``BP_ORDER``).\n\"\"\"\n\ncd = \"\"\"\n``double array[naxis][naxis]`` The ``CDi_ja`` linear transformation\nmatrix.\n\nFor historical compatibility, three alternate specifications of the\nlinear transformations are available in wcslib.  The canonical\n``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\n``CROTAia`` keywords.  Although the latter may not formally co-exist\nwith ``PCi_ja``, the approach here is simply to ignore them if given\nin conjunction with ``PCi_ja``.\n\n`~astropy.wcs.Wcsprm.has_pc`, `~astropy.wcs.Wcsprm.has_cd` and\n`~astropy.wcs.Wcsprm.has_crota` can be used to determine which of\nthese alternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immediately to ``PCi_ja`` by `~astropy.wcs.Wcsprm.set` and\nare nowhere visible to the lower-level routines.  In particular,\n`~astropy.wcs.Wcsprm.set` resets `~astropy.wcs.Wcsprm.cdelt` to unity\nif ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with the latitude axis, `~astropy.wcs.Wcsprm.set` reverts\nto a unity ``PCi_ja`` matrix.\n\"\"\"\n\ncdelt = \"\"\"\n``double array[naxis]`` Coordinate increments (``CDELTia``) for each\ncoord axis.\n\nIf a ``CDi_ja`` linear transformation matrix is present, a warning is\nraised and `~astropy.wcs.Wcsprm.cdelt` is ignored.  The ``CDi_ja``\nmatrix may be deleted by::\n\n  del wcs.wcs.cd\n\nAn undefined value is represented by NaN.\n\"\"\"\n\ncdfix = \"\"\"\ncdfix()\n\nFix erroneously omitted ``CDi_ja`` keywords.\n\nSets the diagonal element of the ``CDi_ja`` matrix to unity if all\n``CDi_ja`` keywords associated with a given axis were omitted.\nAccording to Paper I, if any ``CDi_ja`` keywords at all are given in a\nFITS header then those not given default to zero.  This results in a\nsingular matrix with an intersecting row and column of zeros.\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\ncel_offset = \"\"\"\n``boolean`` Is there an offset?\n\nIf `True`, an offset will be applied to ``(x, y)`` to force ``(x, y) =\n(0, 0)`` at the fiducial point, (phi_0, theta_0).  Default is `False`.\n\"\"\"\n\ncelfix = \"\"\"\nTranslates AIPS-convention celestial projection types, ``-NCP`` and\n``-GLS``.\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\ncname = \"\"\"\n``list of strings`` A list of the coordinate axis names, from\n``CNAMEia``.\n\"\"\"\n\ncolax = \"\"\"\n``int array[naxis]`` An array recording the column numbers for each\naxis in a pixel list.\n\"\"\"\n\ncolnum = \"\"\"\n``int`` Column of FITS binary table associated with this WCS.\n\nWhere the coordinate representation is associated with an image-array\ncolumn in a FITS binary table, this property may be used to record the\nrelevant column number.\n\nIt should be set to zero for an image header or pixel list.\n\"\"\"\n\ncompare = \"\"\"\ncompare(other, cmp=0, tolerance=0.0)\n\nCompare two Wcsprm objects for equality.\n\nParameters\n----------\n\nother : Wcsprm\n    The other Wcsprm object to compare to.\n...\ntolerance : float, optional\n    The amount of tolerance required.  For example, for a value of\n    1e-6, all floating-point values in the objects must be equal to\n    the first 6 decimal places.  The default value of 0.0 implies\n    exact equality.\n\nReturns\n-------\nequal : bool\n\"\"\"\n\nconvert = \"\"\"\nconvert(array)\n\nPerform the unit conversion on the elements of the given *array*,\nreturning an array of the same shape.\n\"\"\"\n\ncoord = \"\"\"\n``double array[K_M]...[K_2][K_1][M]`` The tabular coordinate array.\n\nHas the dimensions::\n\n    (K_M, ... K_2, K_1, M)\n\n(see `~astropy.wcs.Tabprm.K`) i.e. with the `M` dimension\nvarying fastest so that the `M` elements of a coordinate vector are\nstored contiguously in memory.\n\"\"\"\n\ncopy = \"\"\"\nCreates a deep copy of the WCS object.\n\"\"\"\n\ncpdis1 = \"\"\"\n`~astropy.wcs.DistortionLookupTable`\n\nThe pre-linear transformation distortion lookup table, ``CPDIS1``.\n\"\"\"\n\ncpdis2 = \"\"\"\n`~astropy.wcs.DistortionLookupTable`\n\nThe pre-linear transformation distortion lookup table, ``CPDIS2``.\n\"\"\"\n\ncrder = \"\"\"\n``double array[naxis]`` The random error in each coordinate axis,\n``CRDERia``.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\ncrota = \"\"\"\n``double array[naxis]`` ``CROTAia`` keyvalues for each coordinate\naxis.\n\nFor historical compatibility, three alternate specifications of the\nlinear transformations are available in wcslib.  The canonical\n``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\n``CROTAia`` keywords.  Although the latter may not formally co-exist\nwith ``PCi_ja``, the approach here is simply to ignore them if given\nin conjunction with ``PCi_ja``.\n\n`~astropy.wcs.Wcsprm.has_pc`, `~astropy.wcs.Wcsprm.has_cd` and\n`~astropy.wcs.Wcsprm.has_crota` can be used to determine which of\nthese alternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immediately to ``PCi_ja`` by `~astropy.wcs.Wcsprm.set` and\nare nowhere visible to the lower-level routines.  In particular,\n`~astropy.wcs.Wcsprm.set` resets `~astropy.wcs.Wcsprm.cdelt` to unity\nif ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with the latitude axis, `~astropy.wcs.Wcsprm.set` reverts\nto a unity ``PCi_ja`` matrix.\n\"\"\"\n\ncrpix = \"\"\"\n``double array[naxis]`` Coordinate reference pixels (``CRPIXja``) for\neach pixel axis.\n\"\"\"\n\ncrval = \"\"\"\n``double array[naxis]`` Coordinate reference values (``CRVALia``) for\neach coordinate axis.\n\"\"\"\n\ncrval_tabprm = \"\"\"\n``double array[M]`` Index values for the reference pixel for each of\nthe tabular coord axes.\n\"\"\"\n\ncsyer = \"\"\"\n``double array[naxis]`` The systematic error in the coordinate value\naxes, ``CSYERia``.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nctype = \"\"\"\n``list of strings[naxis]`` List of ``CTYPEia`` keyvalues.\n\nThe `~astropy.wcs.Wcsprm.ctype` keyword values must be in upper case\nand there must be zero or one pair of matched celestial axis types,\nand zero or one spectral axis.\n\"\"\"\n\ncubeface = \"\"\"\n``int`` Index into the ``pixcrd`` (pixel coordinate) array for the\n``CUBEFACE`` axis.\n\nThis is used for quadcube projections where the cube faces are stored\non a separate axis.\n\nThe quadcube projections (``TSC``, ``CSC``, ``QSC``) may be\nrepresented in FITS in either of two ways:\n\n...\n      three-dimensional structure using a ``CUBEFACE`` axis indexed\n      from 0 to 5 as above.\n\nThese routines support both methods; `~astropy.wcs.Wcsprm.set`\ndetermines which is being used by the presence or absence of a\n``CUBEFACE`` axis in `~astropy.wcs.Wcsprm.ctype`.\n`~astropy.wcs.Wcsprm.p2s` and `~astropy.wcs.Wcsprm.s2p` translate the\n``CUBEFACE`` axis representation to the single plane representation\nunderstood by the lower-level projection routines.\n\"\"\"\n\ncunit = \"\"\"\n``list of astropy.UnitBase[naxis]`` List of ``CUNITia`` keyvalues as\n`astropy.units.UnitBase` instances.\n\nThese define the units of measurement of the ``CRVALia``, ``CDELTia``\nand ``CDi_ja`` keywords.\n\nAs ``CUNITia`` is an optional header keyword,\n`~astropy.wcs.Wcsprm.cunit` may be left blank but otherwise is\nexpected to contain a standard units specification as defined by WCS\nPaper I.  `~astropy.wcs.Wcsprm.unitfix` is available to translate\ncommonly used non-standard units specifications but this must be done\nas a separate step before invoking `~astropy.wcs.Wcsprm.set`.\n\nFor celestial axes, if `~astropy.wcs.Wcsprm.cunit` is not blank,\n`~astropy.wcs.Wcsprm.set` uses ``wcsunits`` to parse it and scale\n`~astropy.wcs.Wcsprm.cdelt`, `~astropy.wcs.Wcsprm.crval`, and\n`~astropy.wcs.Wcsprm.cd` to decimal degrees.  It then resets\n`~astropy.wcs.Wcsprm.cunit` to ``\"deg\"``.\n\nFor spectral axes, if `~astropy.wcs.Wcsprm.cunit` is not blank,\n`~astropy.wcs.Wcsprm.set` uses ``wcsunits`` to parse it and scale\n`~astropy.wcs.Wcsprm.cdelt`, `~astropy.wcs.Wcsprm.crval`, and\n`~astropy.wcs.Wcsprm.cd` to SI units.  It then resets\n`~astropy.wcs.Wcsprm.cunit` accordingly.\n\n`~astropy.wcs.Wcsprm.set` ignores `~astropy.wcs.Wcsprm.cunit` for\nother coordinate types; `~astropy.wcs.Wcsprm.cunit` may be used to\nlabel coordinate values.\n\"\"\"\n\ncylfix = \"\"\"\ncylfix()\n\nFixes WCS keyvalues for malformed cylindrical projections.\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\ndata = \"\"\"\n``float array`` The array data for the\n`~astropy.wcs.DistortionLookupTable`.\n\"\"\"\n\ndata_wtbarr = \"\"\"\n``double array``\n\nThe array data for the BINTABLE.\n\"\"\"\n\ndateavg = \"\"\"\n``string`` Representative mid-point of the date of observation.\n\nIn ISO format, ``yyyy-mm-ddThh:mm:ss``.\n\nSee also\n--------\nastropy.wcs.Wcsprm.dateobs\n\"\"\"\n\ndateobs = \"\"\"\n``string`` Start of the date of observation.\n\nIn ISO format, ``yyyy-mm-ddThh:mm:ss``.\n\nSee also\n--------\nastropy.wcs.Wcsprm.dateavg\n\"\"\"\n\ndatfix = \"\"\"\ndatfix()\n\nTranslates the old ``DATE-OBS`` date format to year-2000 standard form\n``(yyyy-mm-ddThh:mm:ss)`` and derives ``MJD-OBS`` from it if not\nalready set.\n\nAlternatively, if `~astropy.wcs.Wcsprm.mjdobs` is set and\n`~astropy.wcs.Wcsprm.dateobs` isn't, then `~astropy.wcs.Wcsprm.datfix`\nderives `~astropy.wcs.Wcsprm.dateobs` from it.  If both are set but\ndisagree by more than half a day then `ValueError` is raised.\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\ndelta = \"\"\"\n``double array[M]`` (read-only) Interpolated indices into the coord\narray.\n\nArray of interpolated indices into the coordinate array such that\nUpsilon_m, as defined in Paper III, is equal to\n(`~astropy.wcs.Tabprm.p0` [m] + 1) + delta[m].\n\"\"\"\n\ndet2im = \"\"\"\nConvert detector coordinates to image plane coordinates.\n\"\"\"\n\ndet2im1 = \"\"\"\nA `~astropy.wcs.DistortionLookupTable` object for detector to image plane\ncorrection in the *x*-axis.\n\"\"\"\n\ndet2im2 = \"\"\"\nA `~astropy.wcs.DistortionLookupTable` object for detector to image plane\ncorrection in the *y*-axis.\n\"\"\"\n\ndims = \"\"\"\n``int array[ndim]`` (read-only)\n\nThe dimensions of the tabular array\n`~astropy.wcs.Wtbarr.data`.\n\"\"\"\n\nDistortionLookupTable = \"\"\"\nDistortionLookupTable(*table*, *crpix*, *crval*, *cdelt*)\n\nRepresents a single lookup table for a `distortion paper`_\ntransformation.\n\nParameters\n----------\ntable : 2-dimensional array\n    The distortion lookup table.\n\ncrpix : 2-tuple\n    The distortion array reference pixel\n\ncrval : 2-tuple\n    The image array pixel coordinate\n\ncdelt : 2-tuple\n    The grid step size\n\"\"\"\n\nequinox = \"\"\"\n``double`` The equinox associated with dynamical equatorial or\necliptic coordinate systems.\n\n``EQUINOXa`` (or ``EPOCH`` in older headers).  Not applicable to ICRS\nequatorial or ecliptic coordinates.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nextlev = \"\"\"\n``int`` (read-only)\n\n``EXTLEV`` identifying the binary table extension.\n\"\"\"\n\nextnam = \"\"\"\n``str`` (read-only)\n\n``EXTNAME`` identifying the binary table extension.\n\"\"\"\n\nextrema = \"\"\"\n``double array[K_M]...[K_2][2][M]`` (read-only)\n\nAn array recording the minimum and maximum value of each element of\nthe coordinate vector in each row of the coordinate array, with the\ndimensions::\n\n    (K_M, ... K_2, 2, M)\n\n(see `~astropy.wcs.Tabprm.K`).  The minimum is recorded\nin the first element of the compressed K_1 dimension, then the\nmaximum.  This array is used by the inverse table lookup function to\nspeed up table searches.\n\"\"\"\n\nextver = \"\"\"\n``int`` (read-only)\n\n``EXTVER`` identifying the binary table extension.\n\"\"\"\n\nfind_all_wcs = \"\"\"\nfind_all_wcs(relax=0, keysel=0)\n\nFind all WCS transformations in the header.\n\nParameters\n----------\n\nheader : str\n    The raw FITS header data.\n...\n\n    - ``WCSHDR_PIXLIST``: Pixel list keywords.\n\n    If zero, there is no restriction.  If -1, `wcspih` is called,\n    rather than `wcstbh`.\n\nReturns\n-------\nwcs_list : list of `~astropy.wcs.Wcsprm` objects\n\"\"\"\n\nfix = \"\"\"\nfix(translate_units='', naxis=0)\n\nApplies all of the corrections handled separately by\n`~astropy.wcs.Wcsprm.datfix`, `~astropy.wcs.Wcsprm.unitfix`,\n`~astropy.wcs.Wcsprm.celfix`, `~astropy.wcs.Wcsprm.spcfix`,\n`~astropy.wcs.Wcsprm.cylfix` and `~astropy.wcs.Wcsprm.cdfix`.\n\nParameters\n----------\n...\n    - `~astropy.wcs.Wcsprm.datfix`\n\n    - `~astropy.wcs.Wcsprm.unitfix`\n\n    - `~astropy.wcs.Wcsprm.celfix`\n\n    - `~astropy.wcs.Wcsprm.spcfix`\n\n    - `~astropy.wcs.Wcsprm.cylfix`\n\"\"\"\n\nget_offset = \"\"\"\nget_offset(x, y) -> (x, y)\n\nReturns the offset as defined in the distortion lookup table.\n\nReturns\n-------\ncoordinate : coordinate pair\n    The offset from the distortion table for pixel point (*x*, *y*).\n\"\"\"\n\nget_cdelt = \"\"\"\nget_cdelt() -> double array[naxis]\n\nCoordinate increments (``CDELTia``) for each coord axis.\n\nReturns the ``CDELT`` offsets in read-only form.  Unlike the\n`~astropy.wcs.Wcsprm.cdelt` property, this works even when the header\nspecifies the linear transformation matrix in one of the alternative\n``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nto the linear transformation matrix, but don't care how it was\nspecified in the header.\n\"\"\"\n\nget_pc = \"\"\"\nget_pc() -> double array[naxis][naxis]\n\nReturns the ``PC`` matrix in read-only form.  Unlike the\n`~astropy.wcs.Wcsprm.pc` property, this works even when the header\nspecifies the linear transformation matrix in one of the alternative\n``CDi_ja`` or ``CROTAia`` forms.  This is useful when you want access\nto the linear transformation matrix, but don't care how it was\nspecified in the header.\n\"\"\"\n\nget_ps = \"\"\"\nget_ps() -> list of tuples\n\nReturns ``PSi_ma`` keywords for each *i* and *m*.\n\nReturns\n-------\nps : list of tuples\n\n    Returned as a list of tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PSi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PSi_ma``, (i.e. 0-relative)\n\n    - *value*: string.  Parameter value.\n\nSee also\n--------\nastropy.wcs.Wcsprm.set_ps : Set ``PSi_ma`` values\n\"\"\"\n\nget_pv = \"\"\"\nget_pv() -> list of tuples\n\nReturns ``PVi_ma`` keywords for each *i* and *m*.\n\nReturns\n-------\n\n    Returned as a list of tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PVi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PVi_ma``, (i.e. 0-relative)\n\n    - *value*: string. Parameter value.\n\nSee also\n--------\nastropy.wcs.Wcsprm.set_pv : Set ``PVi_ma`` values\n\nNotes\n-----\n\nNote that, if they were not given, `~astropy.wcs.Wcsprm.set` resets\nthe entries for ``PVi_1a``, ``PVi_2a``, ``PVi_3a``, and ``PVi_4a`` for\nlongitude axis *i* to match (``phi_0``, ``theta_0``), the native\nlongitude and latitude of the reference point given by ``LONPOLEa``\nand ``LATPOLEa``.\n\"\"\"\n\nhas_cd = \"\"\"\nhas_cd() -> bool\n\nReturns `True` if ``CDi_ja`` is present.\n\n``CDi_ja`` is an alternate specification of the linear transformation\nmatrix, maintained for historical compatibility.\n\nMatrix elements in the IRAF convention are equivalent to the product\n``CDi_ja = CDELTia * PCi_ja``, but the defaults differ from that of\nthe ``PCi_ja`` matrix.  If one or more ``CDi_ja`` keywords are present\nthen all unspecified ``CDi_ja`` default to zero.  If no ``CDi_ja`` (or\n``CROTAia``) keywords are present, then the header is assumed to be in\n``PCi_ja`` form whether or not any ``PCi_ja`` keywords are present\nsince this results in an interpretation of ``CDELTia`` consistent with\nthe original FITS specification.\n\nWhile ``CDi_ja`` may not formally co-exist with ``PCi_ja``, it may\nco-exist with ``CDELTia`` and ``CROTAia`` which are to be ignored.\n\nSee also\n--------\nastropy.wcs.Wcsprm.cd : Get the raw ``CDi_ja`` values.\n\"\"\"\n\nhas_cdi_ja = \"\"\"\nhas_cdi_ja() -> bool\n\nAlias for `~astropy.wcs.Wcsprm.has_cd`.  Maintained for backward\ncompatibility.\n\"\"\"\n\nhas_crota = \"\"\"\nhas_crota() -> bool\n\nReturns `True` if ``CROTAia`` is present.\n\n``CROTAia`` is an alternate specification of the linear transformation\nmatrix, maintained for historical compatibility.\n\nIn the AIPS convention, ``CROTAia`` may only be associated with the\nlatitude axis of a celestial axis pair.  It specifies a rotation in\nthe image plane that is applied *after* the ``CDELTia``; any other\n``CROTAia`` keywords are ignored.\n\n``CROTAia`` may not formally co-exist with ``PCi_ja``.  ``CROTAia`` and\n``CDELTia`` may formally co-exist with ``CDi_ja`` but if so are to be\nignored.\n\nSee also\n--------\nastropy.wcs.Wcsprm.crota : Get the raw ``CROTAia`` values\n\"\"\"\n\nhas_crotaia = \"\"\"\nhas_crotaia() -> bool\n\nAlias for `~astropy.wcs.Wcsprm.has_crota`.  Maintained for backward\ncompatibility.\n\"\"\"\n\nhas_pc = \"\"\"\nhas_pc() -> bool\n\nReturns `True` if ``PCi_ja`` is present.  ``PCi_ja`` is the\nrecommended way to specify the linear transformation matrix.\n\nSee also\n--------\nastropy.wcs.Wcsprm.pc : Get the raw ``PCi_ja`` values\n\"\"\"\n\nhas_pci_ja = \"\"\"\nhas_pci_ja() -> bool\n\nAlias for `~astropy.wcs.Wcsprm.has_pc`.  Maintained for backward\ncompatibility.\n\"\"\"\n\ni = \"\"\"\n``int`` (read-only)\n\nImage axis number.\n\"\"\"\n\nimgpix_matrix = \"\"\"\n``double array[2][2]`` (read-only) Inverse of the ``CDELT`` or ``PC``\nmatrix.\n\nInverse containing the product of the ``CDELTia`` diagonal matrix and\nthe ``PCi_ja`` matrix.\n\"\"\"\n\nis_unity = \"\"\"\nis_unity() -> bool\n\nReturns `True` if the linear transformation matrix\n(`~astropy.wcs.Wcsprm.cd`) is unity.\n\"\"\"\n\nK = \"\"\"\n``int array[M]`` (read-only) The lengths of the axes of the coordinate\narray.\n\nAn array of length `M` whose elements record the lengths of the axes of\nthe coordinate array and of each indexing vector.\n\"\"\"\n\nkind = \"\"\"\n``str`` (read-only)\n\nCharacter identifying the wcstab array type:\n\n    - ``'c'``: coordinate array,\n    - ``'i'``: index vector.\n\"\"\"\n\nlat = \"\"\"\n``int`` (read-only) The index into the world coord array containing\nlatitude values.\n\"\"\"\n\nlatpole = \"\"\"\n``double`` The native latitude of the celestial pole, ``LATPOLEa`` (deg).\n\"\"\"\n\nlattyp = \"\"\"\n``string`` (read-only) Celestial axis type for latitude.\n\nFor example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\n\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\n``CTYPEia`` but with trailing dashes removed.\n\"\"\"\n\nlng = \"\"\"\n``int`` (read-only) The index into the world coord array containing\nlongitude values.\n\"\"\"\n\nlngtyp = \"\"\"\n``string`` (read-only) Celestial axis type for longitude.\n\nFor example, \"RA\", \"DEC\", \"GLON\", \"GLAT\", etc. extracted from \"RA--\",\n\"DEC-\", \"GLON\", \"GLAT\", etc. in the first four characters of\n``CTYPEia`` but with trailing dashes removed.\n\"\"\"\n\nlonpole = \"\"\"\n``double`` The native longitude of the celestial pole.\n\n``LONPOLEa`` (deg).\n\"\"\"\n\nM = \"\"\"\n``int`` (read-only) Number of tabular coordinate axes.\n\"\"\"\n\nm = \"\"\"\n``int`` (read-only)\n\nArray axis number for index vectors.\n\"\"\"\n\nmap = \"\"\"\n``int array[M]`` Association between axes.\n\nA vector of length `~astropy.wcs.Tabprm.M` that defines\nthe association between axis *m* in the *M*-dimensional coordinate\narray (1 <= *m* <= *M*) and the indices of the intermediate world\ncoordinate and world coordinate arrays.\n\nWhen the intermediate and world coordinate arrays contain the full\ncomplement of coordinate elements in image-order, as will usually be\nthe case, then ``map[m-1] == i-1`` for axis *i* in the *N*-dimensional\nimage (1 <= *i* <= *N*).  In terms of the FITS keywords::\n\n    map[PVi_3a - 1] == i - 1.\n\nHowever, a different association may result if the intermediate\ncoordinates, for example, only contains a (relevant) subset of\nintermediate world coordinate elements.  For example, if *M* == 1 for\nan image with *N* > 1, it is possible to fill the intermediate\ncoordinates with the relevant coordinate element with ``nelem`` set to\n1.  In this case ``map[0] = 0`` regardless of the value of *i*.\n\"\"\"\n\nmix = \"\"\"\nmix(mixpix, mixcel, vspan, vstep, viter, world, pixcrd, origin)\n\nGiven either the celestial longitude or latitude plus an element of\nthe pixel coordinate, solves for the remaining elements by iterating\non the unknown celestial coordinate element using\n`~astropy.wcs.Wcsprm.s2p`.\n\nParameters\n----------\n...\nnative pole of a projection in which the pole is represented as a\nfinite curve, for example the zenithals and conics.  In such cases two\nor more valid solutions may exist but `~astropy.wcs.Wcsprm.mix` only\never returns one.\n\nBecause of its generality, `~astropy.wcs.Wcsprm.mix` is very\ncompute-intensive.  For compute-limited applications, more efficient\nspecial-case solvers could be written for simple projections, for\nexample non-oblique cylindrical projections.\n\"\"\".format(__.ORIGIN())\n\nmjdavg = \"\"\"\n``double`` Modified Julian Date corresponding to ``DATE-AVG``.\n\n``(MJD = JD - 2400000.5)``.\n\nAn undefined value is represented by NaN.\n\nSee also\n--------\nastropy.wcs.Wcsprm.mjdobs\n\"\"\"\n\nmjdobs = \"\"\"\n``double`` Modified Julian Date corresponding to ``DATE-OBS``.\n\n``(MJD = JD - 2400000.5)``.\n\nAn undefined value is represented by NaN.\n\nSee also\n--------\nastropy.wcs.Wcsprm.mjdavg\n\"\"\"\n\nname = \"\"\"\n``string`` The name given to the coordinate representation\n``WCSNAMEa``.\n\"\"\"\n\nnaxis = \"\"\"\n``int`` (read-only) The number of axes (pixel and coordinate).\n\nGiven by the ``NAXIS`` or ``WCSAXESa`` keyvalues.\n\nThe number of coordinate axes is determined at parsing time, and can\nnot be subsequently changed.\n\nIt is determined from the highest of the following:\n\n  1. ``NAXIS``\n\n  2. ``WCSAXESa``\n\n  3. The highest axis number in any parameterized WCS keyword.  The\n     keyvalue, as well as the keyword, must be syntactically valid\n     otherwise it will not be considered.\n\nIf none of these keyword types is present, i.e. if the header only\ncontains auxiliary WCS keywords for a particular coordinate\nrepresentation, then no coordinate description is constructed for it.\n\nThis value may differ for different coordinate representations of the\nsame image.\n\"\"\"\n\nnc = \"\"\"\n``int`` (read-only) Total number of coord vectors in the coord array.\n\nTotal number of coordinate vectors in the coordinate array being the\nproduct K_1 * K_2 * ... * K_M.\n\"\"\"\n\nndim = \"\"\"\n``int`` (read-only)\n\nExpected dimensionality of the wcstab array.\n\"\"\"\n\nobsgeo = \"\"\"\n``double array[3]`` Location of the observer in a standard terrestrial\nreference frame.\n\n``OBSGEO-X``, ``OBSGEO-Y``, ``OBSGEO-Z`` (in meters).\n\nAn undefined value is represented by NaN.\n\"\"\"\n\np0 = \"\"\"\n``int array[M]`` Interpolated indices into the coordinate array.\n\nVector of length `~astropy.wcs.Tabprm.M` of interpolated\nindices into the coordinate array such that Upsilon_m, as defined in\nPaper III, is equal to ``(p0[m] + 1) + delta[m]``.\n\"\"\"\n\np2s = \"\"\"\np2s(pixcrd, origin)\n\nConverts pixel to world coordinates.\n\nParameters\n----------\n\npixcrd : double array[ncoord][nelem]\n    Array of pixel coordinates.\n...\n    Invalid coordinate transformation parameters.\n\nInvalidTransformError\n    Ill-conditioned coordinate transformation parameters.\n\nSee also\n--------\nastropy.wcs.Wcsprm.lat, astropy.wcs.Wcsprm.lng\n    Definition of the latitude and longitude axes\n\"\"\".format(__.ORIGIN())\n\np4_pix2foc = \"\"\"\np4_pix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nConvert pixel coordinates to focal plane coordinates using `distortion\npaper`_ lookup-table correction.\n\nParameters\n----------\npixcrd : double array[ncoord][nelem].\n    Array of pixel coordinates.\n\n{0}\n\nReturns\n-------\nfoccrd : double array[ncoord][nelem]\n    Returns an array of focal plane coordinates.\n\nRaises\n------\nMemoryError\n    Memory allocation failed.\n\nValueError\n    Invalid coordinate transformation parameters.\n\"\"\".format(__.ORIGIN())\n\npc = \"\"\"\n``double array[naxis][naxis]`` The ``PCi_ja`` (pixel coordinate)\ntransformation matrix.\n\nThe order is::\n\n  [[PC1_1, PC1_2],\n   [PC2_1, PC2_2]]\n\nFor historical compatibility, three alternate specifications of the\nlinear transformations are available in wcslib.  The canonical\n``PCi_ja`` with ``CDELTia``, ``CDi_ja``, and the deprecated\n``CROTAia`` keywords.  Although the latter may not formally co-exist\nwith ``PCi_ja``, the approach here is simply to ignore them if given\nin conjunction with ``PCi_ja``.\n\n`~astropy.wcs.Wcsprm.has_pc`, `~astropy.wcs.Wcsprm.has_cd` and\n`~astropy.wcs.Wcsprm.has_crota` can be used to determine which of\nthese alternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immediately to ``PCi_ja`` by `~astropy.wcs.Wcsprm.set` and\nare nowhere visible to the lower-level routines.  In particular,\n`~astropy.wcs.Wcsprm.set` resets `~astropy.wcs.Wcsprm.cdelt` to unity\nif ``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with the latitude axis, `~astropy.wcs.Wcsprm.set` reverts\nto a unity ``PCi_ja`` matrix.\n\"\"\"\n\nphi0 = \"\"\"\n``double`` The native latitude of the fiducial point.\n\nThe point whose celestial coordinates are given in ``ref[1:2]``.  If\nundefined (NaN) the initialization routine, `~astropy.wcs.Wcsprm.set`,\nwill set this to a projection-specific default.\n\nSee also\n--------\nastropy.wcs.Wcsprm.theta0\n\"\"\"\n\npix2foc = \"\"\"\npix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nPerform both `SIP`_ polynomial and `distortion paper`_ lookup-table\ncorrection in parallel.\n\nParameters\n----------\npixcrd : double array[ncoord][nelem]\n    Array of pixel coordinates.\n\n{0}\n\nReturns\n-------\nfoccrd : double array[ncoord][nelem]\n    Returns an array of focal plane coordinates.\n\nRaises\n------\nMemoryError\n    Memory allocation failed.\n\nValueError\n    Invalid coordinate transformation parameters.\n\"\"\".format(__.ORIGIN())\n\npiximg_matrix = \"\"\"\n``double array[2][2]`` (read-only) Matrix containing the product of\nthe ``CDELTia`` diagonal matrix and the ``PCi_ja`` matrix.\n\"\"\"\n\nprint_contents = \"\"\"\nprint_contents()\n\nPrint the contents of the `~astropy.wcs.Wcsprm` object to stdout.\nProbably only useful for debugging purposes, and may be removed in the\nfuture.\n\nTo get a string of the contents, use `repr`.\n\"\"\"\n\nprint_contents_tabprm = \"\"\"\nprint_contents()\n\nPrint the contents of the `~astropy.wcs.Tabprm` object to\nstdout.  Probably only useful for debugging purposes, and may be\nremoved in the future.\n\nTo get a string of the contents, use `repr`.\n\"\"\"\n\nradesys = \"\"\"\n``string`` The equatorial or ecliptic coordinate system type,\n``RADESYSa``.\n\"\"\"\n\nrestfrq = \"\"\"\n``double`` Rest frequency (Hz) from ``RESTFRQa``.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nrestwav = \"\"\"\n``double`` Rest wavelength (m) from ``RESTWAVa``.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nrow = \"\"\"\n``int`` (read-only)\n\nTable row number.\n\"\"\"\n\ns2p = \"\"\"\ns2p(world, origin)\n\nTransforms world coordinates to pixel coordinates.\n\nParameters\n----------\nworld : double array[ncoord][nelem]\n    Array of world coordinates, in decimal degrees.\n\n...\n   Invalid coordinate transformation parameters.\n\nInvalidTransformError\n    Ill-conditioned coordinate transformation parameters.\n\nSee also\n--------\nastropy.wcs.Wcsprm.lat, astropy.wcs.Wcsprm.lng\n    Definition of the latitude and longitude axes\n\"\"\".format(__.ORIGIN())\n\nsense = \"\"\"\n``int array[M]`` +1 if monotonically increasing, -1 if decreasing.\n\nA vector of length `~astropy.wcs.Tabprm.M` whose elements\nindicate whether the corresponding indexing vector is monotonically\nincreasing (+1), or decreasing (-1).\n\"\"\"\n\nset = \"\"\"\nset()\n\nSets up a WCS object for use according to information supplied within\nit.\n\nNote that this routine need not be called directly; it will be invoked\nby `~astropy.wcs.Wcsprm.p2s` and `~astropy.wcs.Wcsprm.s2p` if\nnecessary.\n\n...\n\nValueError\n    Invalid parameter value.\n\nInvalidTransformError\n    Invalid coordinate transformation parameters.\n\nInvalidTransformError\n    Ill-conditioned coordinate transformation parameters.\n\"\"\"\n\nset_tabprm = \"\"\"\nset()\n\nAllocates memory for work arrays.\n\nAlso sets up the class according to information supplied within it.\n\nNote that this routine need not be called directly; it will be invoked\nby functions that need it.\n\nRaises\n------\nMemoryError\n    Memory allocation failed.\n\nInvalidTabularParameters\n    Invalid tabular parameters.\n\"\"\"\n\nset_ps = \"\"\"\nset_ps(ps)\n\nSets ``PSi_ma`` keywords for each *i* and *m*.\n\nParameters\n----------\nps : sequence of tuples\n\n    The input must be a sequence of tuples of the form (*i*, *m*,\n    *value*):\n\n    - *i*: int.  Axis number, as in ``PSi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PSi_ma``, (i.e. 0-relative)\n\n    - *value*: string.  Parameter value.\n\nSee also\n--------\nastropy.wcs.Wcsprm.get_ps\n\"\"\"\n\nset_pv = \"\"\"\nset_pv(pv)\n\nSets ``PVi_ma`` keywords for each *i* and *m*.\n\nParameters\n----------\npv : list of tuples\n\n    The input must be a sequence of tuples of the form (*i*, *m*,\n    *value*):\n\n    - *i*: int.  Axis number, as in ``PVi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PVi_ma``, (i.e. 0-relative)\n\n    - *value*: float.  Parameter value.\n\nSee also\n--------\nastropy.wcs.Wcsprm.get_pv\n\"\"\"\n\nsip = \"\"\"\nGet/set the `~astropy.wcs.Sip` object for performing `SIP`_ distortion\ncorrection.\n\"\"\"\n\nSip = \"\"\"\nSip(*a, b, ap, bp, crpix*)\n\nThe `~astropy.wcs.Sip` class performs polynomial distortion correction\nusing the `SIP`_ convention in both directions.\n\nParameters\n----------\na : double array[m+1][m+1]\n    The ``A_i_j`` polynomial for pixel to focal plane transformation.\n...\n\ncrpix : double array[2]\n    The reference pixel.\n\nNotes\n-----\nShupe, D. L., M. Moshir, J. Li, D. Makovoz and R. Narron.  2005.\n\"The SIP Convention for Representing Distortion in FITS Image\nHeaders.\"  ADASS XIV.\n\"\"\"\n\nsip_foc2pix = \"\"\"\nsip_foc2pix(*foccrd, origin*) -> double array[ncoord][nelem]\n\nConvert focal plane coordinates to pixel coordinates using the `SIP`_\npolynomial distortion convention.\n\nParameters\n----------\nfoccrd : double array[ncoord][nelem]\n    Array of focal plane coordinates.\n\n{0}\n\nReturns\n-------\npixcrd : double array[ncoord][nelem]\n    Returns an array of pixel coordinates.\n\nRaises\n------\nMemoryError\n    Memory allocation failed.\n\nValueError\n    Invalid coordinate transformation parameters.\n\"\"\".format(__.ORIGIN())\n\nsip_pix2foc = \"\"\"\nsip_pix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nConvert pixel coordinates to focal plane coordinates using the `SIP`_\npolynomial distortion convention.\n\nParameters\n----------\npixcrd : double array[ncoord][nelem]\n    Array of pixel coordinates.\n\n{0}\n\nReturns\n-------\nfoccrd : double array[ncoord][nelem]\n    Returns an array of focal plane coordinates.\n\nRaises\n------\nMemoryError\n    Memory allocation failed.\n\nValueError\n    Invalid coordinate transformation parameters.\n\"\"\".format(__.ORIGIN())\n\nspcfix = \"\"\"\nspcfix() -> int\n\nTranslates AIPS-convention spectral coordinate types.  {``FREQ``,\n``VELO``, ``FELO``}-{``OBS``, ``HEL``, ``LSR``} (e.g. ``FREQ-LSR``,\n``VELO-OBS``, ``FELO-HEL``)\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\nspec = \"\"\"\n``int`` (read-only) The index containing the spectral axis values.\n\"\"\"\n\nspecsys = \"\"\"\n``string`` Spectral reference frame (standard of rest), ``SPECSYSa``.\n\nSee also\n--------\nastropy.wcs.Wcsprm.ssysobs, astropy.wcs.Wcsprm.velosys\n\"\"\"\n\nsptr = \"\"\"\nsptr(ctype, i=-1)\n\nTranslates the spectral axis in a WCS object.\n\nFor example, a ``FREQ`` axis may be translated into ``ZOPT-F2W`` and\nvice versa.\n\nParameters\n----------\n...\n\nInvalidTransformError\n    Invalid coordinate transformation parameters.\n\nInvalidTransformError\n    Ill-conditioned coordinate transformation parameters.\n\nInvalidSubimageSpecificationError\n    Invalid subimage specification (no spectral axis).\n\"\"\"\n\nssysobs = \"\"\"\n``string`` Spectral reference frame.\n\nThe spectral reference frame in which there is no differential\nvariation in the spectral coordinate across the field-of-view,\n``SSYSOBSa``.\n\nSee also\n--------\nastropy.wcs.Wcsprm.specsys, astropy.wcs.Wcsprm.velosys\n\"\"\"\n\nssyssrc = \"\"\"\n``string`` Spectral reference frame for redshift.\n\nThe spectral reference frame (standard of rest) in which the redshift\nwas measured, ``SSYSSRCa``.\n\"\"\"\n\nsub = \"\"\"\nsub(axes)\n\nExtracts the coordinate description for a subimage from a\n`~astropy.wcs.WCS` object.\n\nThe world coordinate system of the subimage must be separable in the\nsense that the world coordinates at any point in the subimage must\ndepend only on the pixel coordinates of the axes extracted.  In\npractice, this means that the ``PCi_ja`` matrix of the original image\n...\nThe last of these specifies all axis types other than spectral or\nStokes.  Extraction is done in the order specified by ``axes``, i.e. a\nlongitude axis (if present) would be extracted first (via ``axes[0]``)\nand not subsequently (via ``axes[3]``).  Likewise for the latitude and\ncubeface axes in this example.\n\nThe number of dimensions in the returned object may be less than or\ngreater than the length of ``axes``.  However, it will never exceed the\nnumber of axes in the input image.\n\"\"\"\n\ntab = \"\"\"\n``list of Tabprm`` Tabular coordinate objects.\n\nA list of tabular coordinate objects associated with this WCS.\n\"\"\"\n\nTabprm = \"\"\"\nA class to store the information related to tabular coordinates,\ni.e., coordinates that are defined via a lookup table.\n\nThis class can not be constructed directly from Python, but instead is\nreturned from `~astropy.wcs.Wcsprm.tab`.\n\"\"\"\n\ntheta0 = \"\"\"\n``double``  The native longitude of the fiducial point.\n\nThe point whose celestial coordinates are given in ``ref[1:2]``.  If\nundefined (NaN) the initialization routine, `~astropy.wcs.Wcsprm.set`,\nwill set this to a projection-specific default.\n\nSee also\n--------\nastropy.wcs.Wcsprm.phi0\n\"\"\"\n\nto_header = \"\"\"\nto_header(relax=False)\n\n`to_header` translates a WCS object into a FITS header.\n\nThe details of the header depends on context:\n\n    - If the `~astropy.wcs.Wcsprm.colnum` member is non-zero then a\n      binary table image array header will be produced.\n\n...\n      standard.\n\n    - `int`: a bit field selecting specific extensions to write.\n      See :ref:`relaxwrite` for details.\n\nReturns\n-------\nheader : str\n    Raw FITS header as a string.\n\"\"\"\n\nttype = \"\"\"\n``str`` (read-only)\n\n``TTYPEn`` identifying the column of the binary table that contains\nthe wcstab array.\n\"\"\"\n\nunitfix = \"\"\"\nunitfix(translate_units='')\n\nTranslates non-standard ``CUNITia`` keyvalues.\n\nFor example, ``DEG`` -> ``deg``, also stripping off unnecessary\nwhitespace.\n\nParameters\n----------\n...\n    - If the string contains ``\\\"d\\\"``, translate ``\\\"D\\\"`` to ``\\\"d\\\"``.\n\n    Thus ``''`` doesn't do any unsafe translations, whereas ``'shd'``\n    does all of them.\n\nReturns\n-------\nsuccess : int\n    Returns ``0`` for success; ``-1`` if no change required.\n\"\"\"\n\nvelangl = \"\"\"\n``double`` Velocity angle.\n\nThe angle in degrees that should be used to decompose an observed\nvelocity into radial and transverse components.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nvelosys = \"\"\"\n``double`` Relative radial velocity.\n\nThe relative radial velocity (m/s) between the observer and the\nselected standard of rest in the direction of the celestial reference\ncoordinate, ``VELOSYSa``.\n\nAn undefined value is represented by NaN.\n\nSee also\n--------\nastropy.wcs.Wcsprm.specsys, astropy.wcs.Wcsprm.ssysobs\n\"\"\"\n\nvelref = \"\"\"\n``int`` AIPS velocity code.\n\nFrom ``VELREF`` keyword.\n\"\"\"\n\nwcs = \"\"\"\nA `~astropy.wcs.Wcsprm` object to perform the basic `wcslib`_ WCS\ntransformation.\n\"\"\"\n\nWcs = \"\"\"\nWcs(*sip, cpdis, wcsprm, det2im*)\n\nWcs objects amalgamate basic WCS (as provided by `wcslib`_), with\n`SIP`_ and `distortion paper`_ operations.\n\nTo perform all distortion corrections and WCS transformation, use\n``all_pix2world``.\n\nParameters\n----------\nsip : `~astropy.wcs.Sip` object or `None`\n\ncpdis : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\n  ``(None, None)``.\n\nwcsprm : `~astropy.wcs.Wcsprm` object\n\ndet2im : A pair of `~astropy.wcs.DistortionLookupTable` objects, or\n   ``(None, None)``.\n\"\"\"\n\nWcsprm = \"\"\"\nWcsprm(header=None, key=' ', relax=False, naxis=2, keysel=0, colsel=None)\n\n`~astropy.wcs.Wcsprm` performs the core WCS transformations.\n\n.. note::\n    The members of this object correspond roughly to the key/value\n    pairs in the FITS header.  However, they are adjusted and\n    normalized in a number of ways that make performing the WCS\n    transformation easier.  Therefore, they can not be relied upon to\n...\n------\nMemoryError\n     Memory allocation failed.\n\nValueError\n     Invalid key.\n\nKeyError\n     Key not found in FITS header.\n\"\"\"\n\nWtbarr = \"\"\"\nClasses to construct coordinate lookup tables from a binary table\nextension (BINTABLE).\n\nThis class can not be constructed directly from Python, but instead is\nreturned from `~astropy.wcs.Wcsprm.wtb`.\n\"\"\"\n\nzsource = \"\"\"\n``double`` The redshift, ``ZSOURCEa``, of the source.\n\nAn undefined value is represented by NaN.\n\"\"\"\n\nWcsError = \"\"\"\nBase class of all invalid WCS errors.\n\"\"\"\n\nSingularMatrix = \"\"\"\nSingularMatrixError()\n\nThe linear transformation matrix is singular.\n\"\"\"\n\nInconsistentAxisTypes = \"\"\"\nInconsistentAxisTypesError()\n\nThe WCS header inconsistent or unrecognized coordinate axis type(s).\n\"\"\"\n\nInvalidTransform = \"\"\"\nInvalidTransformError()\n\nThe WCS transformation is invalid, or the transformation parameters\nare invalid.\n\"\"\"\n\nInvalidCoordinate = \"\"\"\nInvalidCoordinateError()\n\nOne or more of the world coordinates is invalid.\n\"\"\"\n\nNoSolution = \"\"\"\nNoSolutionError()\n\nNo solution can be found in the given interval.\n\"\"\"\n\nInvalidSubimageSpecification = \"\"\"\nInvalidSubimageSpecificationError()\n\nThe subimage specification is invalid.\n\"\"\"\n\nNonseparableSubimageCoordinateSystem = \"\"\"\nNonseparableSubimageCoordinateSystemError()\n\nNon-separable subimage coordinate system.\n\"\"\"\n\nNoWcsKeywordsFound = \"\"\"\nNoWcsKeywordsFoundError()\n\nNo WCS keywords were found in the given header.\n\"\"\"\n\nInvalidTabularParameters = \"\"\"\nInvalidTabularParametersError()\n\nThe given tabular parameters are invalid.\n\"\"\"\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "astropy__astropy-14995", "found_files": ["astropy/nddata/nddata.py", "astropy/nddata/mixins/ndarithmetic.py", "astropy/nddata/utils.py", "astropy/utils/masked/core.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/nddata/nddata.py": ["class: NDData"], "astropy/nddata/mixins/ndarithmetic.py": ["class: NDArithmeticMixin\nfunction: NDArithmeticMixin._arithmetic\nfunction: NDArithmeticMixin._arithmetic_mask\nfunction: NDArithmeticMixin.multiply"], "astropy/nddata/utils.py": [""]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/nddata/nddata.py\nclass: NDData\n\nastropy/nddata/mixins/ndarithmetic.py\nclass: NDArithmeticMixin\nfunction: NDArithmeticMixin._arithmetic\nfunction: NDArithmeticMixin._arithmetic_mask\nfunction: NDArithmeticMixin.multiply\n```"}], "related_loc_traj": [{"response": "```\nastropy/nddata/nddata.py\nclass: NDData\n\nastropy/nddata/mixins/ndarithmetic.py\nclass: NDArithmeticMixin\nfunction: NDArithmeticMixin._arithmetic\nfunction: NDArithmeticMixin._arithmetic_mask\nfunction: NDArithmeticMixin.multiply\n```", "usage": {"completion_tokens": 64, "prompt_tokens": 2444}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nIn v5.3, NDDataRef mask propagation fails when one of the operand does not have a mask\n### Description\n\nThis applies to v5.3. \r\n\r\nIt looks like when one of the operand does not have a mask, the mask propagation when doing arithmetic, in particular with `handle_mask=np.bitwise_or` fails.  This is not a problem in v5.2.\r\n\r\nI don't know enough about how all that works, but it seems from the error that the operand without a mask is set as a mask of None's and then the bitwise_or tries to operate on an integer and a None and fails.\n\n### Expected behavior\n\nWhen one of the operand does not have mask, the mask that exists should just be copied over to the output.  Or whatever was done in that situation in v5.2 where there's no problem.\n\n### How to Reproduce\n\nThis is with v5.3.   With v5.2, there are no errors.\r\n\r\n```\r\n>>> import numpy as np\r\n>>> from astropy.nddata import NDDataRef\r\n\r\n>>> array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\r\n>>> mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\r\n\r\n>>> nref_nomask = NDDataRef(array)\r\n>>> nref_mask = NDDataRef(array, mask=mask)\r\n\r\n# multiply no mask by constant (no mask * no mask)\r\n>>> nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask   # returns nothing, no mask,  OK\r\n\r\n# multiply no mask by itself (no mask * no mask)\r\n>>> nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask # return nothing, no mask, OK\r\n\r\n# multiply mask by constant (mask * no mask)\r\n>>> nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n\r\n# multiply mask by itself (mask * mask)\r\n>>> nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or).mask\r\narray([[ 0,  1, 64],\r\n       [ 8,  0,  1],\r\n       [ 2,  1,  0]])\r\n\r\n# multiply mask by no mask (mask * no mask)\r\n>>> nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\r\n...\r\nTypeError: unsupported operand type(s) for |: 'int' and 'NoneType'\r\n```\r\n\n\n### Versions\n\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 19:07:22) [Clang 14.0.6 ]\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 5.3\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.24.3\r\n>>> import erfa; print(\"pyerfa\", erfa.__version__)\r\npyerfa 2.0.0.3\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.10.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.7.1\r\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/nddata/nddata.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n# This module implements the base NDData class.\n\n\n\n__all__ = [\"NDData\"]\n\n_meta_doc = \"\"\"`dict`-like : Additional meta information about the dataset.\"\"\"\n\n\nclass NDData(NDDataBase):\n\n    # Instead of a custom property use the MetaData descriptor also used for\n    # Tables. It will check if the meta is dict-like or raise an exception.\n    meta = MetaData(doc=_meta_doc, copy=False)\n\n    def __init__(\n        self,\n        data,\n        uncertainty=None,\n        mask=None,\n        wcs=None,\n        meta=None,\n        unit=None,\n        copy=False,\n        psf=None,\n    ):\n...\n\n    def __str__(self):\n...\n\n    def __repr__(self):\n...\n\n    @property\n    def data(self):\n...\n\n    @property\n    def mask(self):\n...\n\n    @mask.setter\n    def mask(self, value):\n...\n\n    @property\n    def unit(self):\n...\n\n    @property\n    def wcs(self):\n...\n\n    @wcs.setter\n    def wcs(self, wcs):\n...\n\n    @property\n    def psf(self):\n...\n\n    @psf.setter\n    def psf(self, value):\n...\n\n    @property\n    def uncertainty(self):\n...\n\n    @uncertainty.setter\n    def uncertainty(self, value):\n...\n\n```\n\n### File: astropy/nddata/mixins/ndarithmetic.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n# This module implements the Arithmetic mixin to the NDData class.\n\n\n__all__ = [\"NDArithmeticMixin\"]\n\n# Global so it doesn't pollute the class dict unnecessarily:\n\n# Docstring templates for add, subtract, multiply, divide methods.\n_arit_doc = \"\"\"\n    Performs {name} by evaluating ``self`` {op} ``operand``.\n\n    Parameters\n    ----------\n    operand, operand2 : `NDData`-like instance\n        If ``operand2`` is ``None`` or not given it will perform the operation\n        ``self`` {op} ``operand``.\n        If ``operand2`` is given it will perform ``operand`` {op} ``operand2``.\n        If the method was called on a class rather than on the instance\n...\n    -----\n    If a ``callable`` is used for ``mask``, ``wcs`` or ``meta`` the\n    callable must accept the corresponding attributes as first two\n    parameters. If the callable also needs additional parameters these can be\n    defined as ``kwargs`` and must start with ``\"wcs_\"`` (for wcs callable) or\n    ``\"meta_\"`` (for meta callable). This startstring is removed before the\n    callable is called.\n\n    ``\"first_found\"`` can also be abbreviated with ``\"ff\"``.\n    \"\"\"\n\n\nclass NDArithmeticMixin:\n\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n...\n\n    def _arithmetic_data(self, operation, operand, **kwds):\n...\n\n    def _arithmetic_uncertainty(self, operation, operand, result, correlation, **kwds):\n...\n\n    def _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\n...\n\n    def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n...\n\n    def _arithmetic_meta(self, operation, operand, handle_meta, **kwds):\n...\n\n    @sharedmethod\n    @format_doc(_arit_doc, name=\"addition\", op=\"+\")\n    def add(self, operand, operand2=None, **kwargs):\n...\n\n    @sharedmethod\n    @format_doc(_arit_doc, name=\"subtraction\", op=\"-\")\n    def subtract(self, operand, operand2=None, **kwargs):\n...\n\n    @sharedmethod\n    @format_doc(_arit_doc, name=\"multiplication\", op=\"*\")\n    def multiply(self, operand, operand2=None, **kwargs):\n...\n\n    @sharedmethod\n    @format_doc(_arit_doc, name=\"division\", op=\"/\")\n    def divide(self, operand, operand2=None, **kwargs):\n...\n\n    @sharedmethod\n    def sum(self, **kwargs):\n...\n\n    @sharedmethod\n    def mean(self, **kwargs):\n...\n\n    @sharedmethod\n    def min(self, **kwargs):\n...\n\n    @sharedmethod\n    def max(self, **kwargs):\n...\n\n    @sharedmethod\n    def _prepare_then_do_arithmetic(\n        self_or_cls, operation, operand=None, operand2=None, **kwargs\n    ):\n...\n\n```\n\n### File: astropy/nddata/utils.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n__all__ = [\n    \"extract_array\",\n    \"add_array\",\n    \"subpixel_indices\",\n    \"overlap_slices\",\n    \"NoOverlapError\",\n    \"PartialOverlapError\",\n    \"Cutout2D\",\n]\n\n\nclass NoOverlapError(ValueError):\n\n    pass\n\n\nclass PartialOverlapError(ValueError):\n\n    pass\n\n\ndef overlap_slices(large_array_shape, small_array_shape, position, mode=\"partial\"):\n...\n\n\ndef extract_array(\n    array_large,\n    shape,\n    position,\n    mode=\"partial\",\n    fill_value=np.nan,\n    return_position=False,\n):\n...\n\n\ndef add_array(array_large, array_small, position):\n...\n\n\ndef subpixel_indices(position, subsampling):\n...\n\n\nclass Cutout2D:\n\n    def __init__(\n        self, data, position, size, wcs=None, mode=\"trim\", fill_value=np.nan, copy=False\n    ):\n...\n\n    def to_original_position(self, cutout_position):\n...\n\n    def to_cutout_position(self, original_position):\n...\n\n    def plot_on_original(self, ax=None, fill=False, **kwargs):\n...\n\n    @staticmethod\n    def _calc_center(slices):\n...\n\n    @staticmethod\n    def _calc_bbox(slices):\n...\n\n    @lazyproperty\n    def origin_original(self):\n...\n\n    @lazyproperty\n    def origin_cutout(self):\n...\n\n    @staticmethod\n    def _round(a):\n...\n\n    @lazyproperty\n    def position_original(self):\n...\n\n    @lazyproperty\n    def position_cutout(self):\n...\n\n    @lazyproperty\n    def center_original(self):\n...\n\n    @lazyproperty\n    def center_cutout(self):\n...\n\n    @lazyproperty\n    def bbox_original(self):\n...\n\n    @lazyproperty\n    def bbox_cutout(self):\n...\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "astropy__astropy-14182", "found_files": ["astropy/io/ascii/rst.py", "astropy/io/ascii/core.py", "astropy/io/ascii/ui.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/io/ascii/rst.py": ["class: RST\nclass: SimpleRSTHeader\nclass: SimpleRSTData"], "astropy/io/ascii/core.py": ["function: _get_writer\nclass: BaseHeader\nclass: BaseData"], "astropy/io/ascii/ui.py": ["function: write\nfunction: get_writer"]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/io/ascii/rst.py\nclass: RST\nclass: SimpleRSTHeader\nclass: SimpleRSTData\n\nastropy/io/ascii/core.py\nfunction: _get_writer\nclass: BaseHeader\nclass: BaseData\n\nastropy/io/ascii/ui.py\nfunction: write\nfunction: get_writer\n```"}], "related_loc_traj": [{"response": "```\nastropy/io/ascii/rst.py\nclass: RST\nclass: SimpleRSTHeader\nclass: SimpleRSTData\n\nastropy/io/ascii/core.py\nfunction: _get_writer\nclass: BaseHeader\nclass: BaseData\n\nastropy/io/ascii/ui.py\nfunction: write\nfunction: get_writer\n```", "usage": {"completion_tokens": 71, "prompt_tokens": 2889}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nPlease support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/lib/python3/dist-packages/astropy/table/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/registry/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/io/ascii/rst.py ###\n```python\n# Licensed under a 3-clause BSD style license\n\n\nclass SimpleRSTHeader(FixedWidthHeader):\n    position_line = 0\n    start_line = 1\n    splitter_class = DefaultSplitter\n    position_char = \"=\"\n\n    def get_fixedwidth_params(self, line):\n...\n\n\nclass SimpleRSTData(FixedWidthData):\n    start_line = 3\n    end_line = -1\n    splitter_class = FixedWidthTwoLineDataSplitter\n\n\nclass RST(FixedWidth):\n\n    _format_name = \"rst\"\n    _description = \"reStructuredText simple table\"\n    data_class = SimpleRSTData\n    header_class = SimpleRSTHeader\n\n    def __init__(self):\n...\n\n    def write(self, lines):\n...\n\n```\n\n### File: astropy/io/ascii/core.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Global dictionary mapping format arg to the corresponding Reader class\nFORMAT_CLASSES = {}\n\n# Similar dictionary for fast readers\nFAST_CLASSES = {}\n\n\ndef _check_multidim_table(table, max_ndim):\n...\n\n\nclass CsvWriter:\n\n    # Random 16-character string that gets injected instead of any\n    # empty fields and is then replaced post-write with doubled-quotechar.\n    # Created with:\n    # ''.join(random.choice(string.printable[:90]) for _ in range(16))\n    replace_sentinel = \"2b=48Av%0-V3p>bX\"\n\n    def __init__(self, csvfile=None, **kwargs):\n...\n\n    def writerow(self, values):\n...\n\n    def writerows(self, values_list):\n...\n\n    def _writerow(self, writerow_func, values, has_empty):\n...\n\n\nclass MaskedConstant(numpy.ma.core.MaskedConstant):\n\n    def __hash__(self):\n...\n\n    def __copy__(self):\n...\n\n    def __deepcopy__(self, memo):\n...\n\n\nmasked = MaskedConstant()\n\n\nclass InconsistentTableError(ValueError):\n    pass\n\n\nclass OptionalTableImportError(ImportError):\n    pass\n\n\nclass ParameterError(NotImplementedError):\n    pass\n\n\nclass FastOptionsError(NotImplementedError):\n    pass\n\n\nclass NoType:\n    pass\n\n\nclass StrType(NoType):\n    pass\n\n\nclass NumType(NoType):\n    pass\n\n\nclass FloatType(NumType):\n    pass\n\n\nclass BoolType(NoType):\n    pass\n\n\nclass IntType(NumType):\n    pass\n\n\nclass AllType(StrType, FloatType, IntType):\n    pass\n\n\nclass Column:\n\n    def __init__(self, name):\n...\n\n\nclass BaseInputter:\n\n    encoding = None\n\n    def get_lines(self, table, newline=None):\n...\n\n    def process_lines(self, lines):\n...\n\n\nclass BaseSplitter:\n\n    delimiter = None\n\n    def process_line(self, line):\n...\n\n    def process_val(self, val):\n...\n\n    def __call__(self, lines):\n...\n\n    def join(self, vals):\n...\n\n\nclass DefaultSplitter(BaseSplitter):\n\n    delimiter = \" \"\n    quotechar = '\"'\n    doublequote = True\n    escapechar = None\n    quoting = csv.QUOTE_MINIMAL\n    skipinitialspace = True\n    csv_writer = None\n    csv_writer_out = StringIO()\n\n    def process_line(self, line):\n...\n\n    def process_val(self, val):\n...\n\n    def __call__(self, lines):\n...\n\n    def join(self, vals):\n...\n\n\ndef _replace_tab_with_space(line, escapechar, quotechar):\n...\n\n\ndef _get_line_index(line_or_func, lines):\n...\n\n\nclass BaseHeader:\n\n    auto_format = \"col{}\"\n    start_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    names = None\n    write_comment = False\n    write_spacer_lines = [\"ASCII_TABLE_WRITE_SPACER_LINE\"]\n\n    def __init__(self):\n...\n\n    def _set_cols_from_names(self):\n...\n\n    def update_meta(self, lines, meta):\n...\n\n    def get_cols(self, lines):\n...\n\n    def process_lines(self, lines):\n...\n\n    def write_comments(self, lines, meta):\n...\n\n    def write(self, lines):\n...\n\n    @property\n    def colnames(self):\n...\n\n    def remove_columns(self, names):\n...\n\n    def rename_column(self, name, new_name):\n...\n\n    def get_type_map_key(self, col):\n...\n\n    def get_col_type(self, col):\n...\n\n    def check_column_names(self, names, strict_names, guessing):\n...\n\n\nclass BaseData:\n\n    start_line = None\n    end_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    write_spacer_lines = [\"ASCII_TABLE_WRITE_SPACER_LINE\"]\n    fill_include_names = None\n    fill_exclude_names = None\n    fill_values = [(masked, \"\")]\n    formats = {}\n\n    def __init__(self):\n...\n\n    def process_lines(self, lines):\n...\n\n    def get_data_lines(self, lines):\n...\n\n    def get_str_vals(self):\n...\n\n    def masks(self, cols):\n...\n\n    def _set_fill_values(self, cols):\n...\n\n    def _set_masks(self, cols):\n...\n\n    def _replace_vals(self, cols):\n...\n\n    def str_vals(self):\n...\n\n    def write(self, lines):\n...\n\n    def _set_col_formats(self):\n...\n\n\ndef convert_numpy(numpy_type):\n...\n\n\nclass BaseOutputter:\n\n    # User-defined converters which gets set in ascii.ui if a `converter` kwarg\n    # is supplied.\n    converters = {}\n\n    # Derived classes must define default_converters and __call__\n\n    @staticmethod\n    def _validate_and_copy(col, converters):\n...\n\n    def _convert_vals(self, cols):\n...\n\n\ndef _deduplicate_names(names):\n...\n\n\nclass TableOutputter(BaseOutputter):\n\n    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]\n\n    def __call__(self, cols, meta):\n...\n\n\nclass MetaBaseReader(type):\n    def __init__(cls, name, bases, dct):\n...\n\n\ndef _is_number(x):\n...\n\n\ndef _apply_include_exclude_names(table, names, include_names, exclude_names):\n...\n\n\nclass BaseReader(metaclass=MetaBaseReader):\n\n    names = None\n    include_names = None\n    exclude_names = None\n    strict_names = False\n    guessing = False\n    encoding = None\n\n    header_class = BaseHeader\n    data_class = BaseData\n    inputter_class = BaseInputter\n    outputter_class = TableOutputter\n\n    # Max column dimension that writer supports for this format. Exceptions\n    # include ECSV (no limit) and HTML (max_ndim=2).\n    max_ndim = 1\n\n    def __init__(self):\n...\n\n    def _check_multidim_table(self, table):\n...\n\n    def read(self, table):\n...\n\n    def inconsistent_handler(self, str_vals, ncols):\n...\n\n    @property\n    def comment_lines(self):\n...\n\n    def update_table_data(self, table):\n...\n\n    def write_header(self, lines, meta):\n...\n\n    def write(self, table):\n...\n\n\nclass ContinuationLinesInputter(BaseInputter):\n\n    continuation_char = \"\\\\\"\n    replace_char = \" \"\n    # If no_continue is not None then lines matching this regex are not subject\n    # to line continuation.  The initial use case here is Daophot.  In this\n    # case the continuation character is just replaced with replace_char.\n    no_continue = None\n\n    def process_lines(self, lines):\n...\n\n\nclass WhitespaceSplitter(DefaultSplitter):\n    def process_line(self, line):\n...\n\n\nextra_reader_pars = (\n    \"Reader\",\n    \"Inputter\",\n    \"Outputter\",\n    \"delimiter\",\n    \"comment\",\n    \"quotechar\",\n    \"header_start\",\n    \"data_start\",\n    \"data_end\",\n    \"converters\",\n    \"encoding\",\n    \"data_Splitter\",\n    \"header_Splitter\",\n    \"names\",\n    \"include_names\",\n    \"exclude_names\",\n    \"strict_names\",\n    \"fill_values\",\n    \"fill_include_names\",\n    \"fill_exclude_names\",\n)\n\n\ndef _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):\n...\n\n\nextra_writer_pars = (\n    \"delimiter\",\n    \"comment\",\n    \"quotechar\",\n    \"formats\",\n    \"strip_whitespace\",\n    \"names\",\n    \"include_names\",\n    \"exclude_names\",\n    \"fill_values\",\n    \"fill_include_names\",\n    \"fill_exclude_names\",\n)\n\n\ndef _get_writer(Writer, fast_writer, **kwargs):\n...\n\n```\n\n### File: astropy/io/ascii/ui.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_read_trace = []\n\n# Default setting for guess parameter in read()\n_GUESS = True\n\n\ndef _probably_html(table, maxchars=100000):\n...\n\n\ndef set_guess(guess):\n...\n\n\ndef get_reader(Reader=None, Inputter=None, Outputter=None, **kwargs):\n...\n\n\ndef _get_format_class(format, ReaderWriter, label):\n...\n\n\ndef _get_fast_reader_dict(kwargs):\n...\n\n\ndef _validate_read_write_kwargs(read_write, **kwargs):\n...\n\n\ndef _expand_user_if_path(argument):\n...\n\n\ndef read(table, guess=None, **kwargs):\n...\n\n\nread.__doc__ = core.READ_DOCSTRING\n\n\ndef _guess(table, read_kwargs, format, fast_reader):\n...\n\n\ndef _get_guess_kwargs_list(read_kwargs):\n...\n\n\ndef _read_in_chunks(table, **kwargs):\n...\n\n\ndef _read_in_chunks_generator(table, chunk_size, **kwargs):\n...\n\n\nextra_writer_pars = (\n    \"delimiter\",\n    \"comment\",\n    \"quotechar\",\n    \"formats\",\n    \"names\",\n    \"include_names\",\n    \"exclude_names\",\n    \"strip_whitespace\",\n)\n\n\ndef get_writer(Writer=None, fast_writer=True, **kwargs):\n...\n\n\ndef write(\n    table,\n    output=None,\n    format=None,\n    Writer=None,\n    fast_writer=True,\n    *,\n    overwrite=False,\n    **kwargs,\n):\n...\n\n\nwrite.__doc__ = core.WRITE_DOCSTRING\n\n\ndef get_read_trace():\n...\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "astropy__astropy-12907", "found_files": ["astropy/modeling/separable.py", "astropy/modeling/core.py", "astropy/modeling/models.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/modeling/separable.py": ["function: separability_matrix\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable"], "astropy/modeling/core.py": ["class: CompoundModel\nfunction: CompoundModel._make_leaflist\nfunction: CompoundModel.traverse_postorder\nfunction: CompoundModel._format_expression\nfunction: CompoundModel._format_components"], "astropy/modeling/models.py": [""]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable\n\nastropy/modeling/core.py\nclass: CompoundModel\nfunction: CompoundModel._make_leaflist\nfunction: CompoundModel.traverse_postorder\nfunction: CompoundModel._format_expression\nfunction: CompoundModel._format_components\n```"}], "related_loc_traj": [{"response": "```\nastropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable\n\nastropy/modeling/core.py\nclass: CompoundModel\nfunction: CompoundModel._make_leaflist\nfunction: CompoundModel.traverse_postorder\nfunction: CompoundModel._format_expression\nfunction: CompoundModel._format_components\n```", "usage": {"completion_tokens": 87, "prompt_tokens": 4727}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nModeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/modeling/separable.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n__all__ = [\"is_separable\", \"separability_matrix\"]\n\n\ndef is_separable(transform):\n...\n\n\ndef separability_matrix(transform):\n...\n\n\ndef _compute_n_outputs(left, right):\n...\n\n\ndef _arith_oper(left, right):\n...\n\n\ndef _coord_matrix(model, pos, noutp):\n...\n\n\ndef _cstack(left, right):\n...\n\n\ndef _cdot(left, right):\n...\n\n\ndef _separable(transform):\n...\n\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n\n```\n\n### File: astropy/modeling/core.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n           'bind_bounding_box', 'bind_compound_bounding_box']\n\n\ndef _model_oper(oper, **kwargs):\n...\n\n\nclass ModelDefinitionError(TypeError):\n    pass\n\n\nclass _ModelMeta(abc.ABCMeta):\n\n    _is_dynamic = False\n\n    # Default empty dict for _parameters_, which will be empty on model\n    # classes that don't have any Parameters\n\n    def __new__(mcls, name, bases, members, **kwds):\n...\n\n    def __init__(cls, name, bases, members, **kwds):\n...\n\n    def __repr__(cls):\n...\n\n    def _repr_pretty_(cls, p, cycle):\n...\n\n    def __reduce__(cls):\n...\n\n    @property\n    def name(cls):\n...\n\n    @property\n    def _is_concrete(cls):\n...\n\n    def rename(cls, name=None, inputs=None, outputs=None):\n...\n\n    def _create_inverse_property(cls, members):\n...\n\n    def _create_bounding_box_property(cls, members):\n...\n\n    def _create_bounding_box_subclass(cls, func, sig):\n...\n\n    def _handle_special_methods(cls, members, pdict):\n...\n\n    # *** Arithmetic operators for creating compound models ***\n    __add__ = _model_oper('+')\n    __sub__ = _model_oper('-')\n    __mul__ = _model_oper('*')\n    __truediv__ = _model_oper('/')\n    __pow__ = _model_oper('**')\n    __or__ = _model_oper('|')\n    __and__ = _model_oper('&')\n    _fix_inputs = _model_oper('fix_inputs')\n\n    # *** Other utilities ***\n\n    def _format_cls_repr(cls, keywords=[]):\n...\n\n\nclass Model(metaclass=_ModelMeta):\n\n    parameter_constraints = Parameter.constraints\n\n    model_constraints = ('eqcons', 'ineqcons')\n\n    param_names = ()\n\n    n_inputs = 0\n    n_outputs = 0\n\n    standard_broadcasting = True\n    fittable = False\n    linear = True\n    _separable = None\n    meta = metadata.MetaData()\n\n    # By default models either use their own inverse property or have no\n    # inverse at all, but users may also assign a custom inverse to a model,\n    # optionally; in that case it is of course up to the user to determine\n    # whether their inverse is *actually* an inverse to the model they assign\n    # it to.\n    _inverse = None\n    _user_inverse = None\n\n    _bounding_box = None\n    _user_bounding_box = None\n\n    _has_inverse_bounding_box = False\n\n    # Default n_models attribute, so that __len__ is still defined even when a\n    # model hasn't completed initialization yet\n    _n_models = 1\n\n    # New classes can set this as a boolean value.\n    # It is converted to a dictionary mapping input name to a boolean value.\n    _input_units_strict = False\n\n    # Allow dimensionless input (and corresponding output). If this is True,\n    # input values to evaluate will gain the units specified in input_units. If\n    # this is a dictionary then it should map input name to a bool to allow\n    # dimensionless numbers for that input.\n    # Only has an effect if input_units is defined.\n    _input_units_allow_dimensionless = False\n\n    # Default equivalencies to apply to input values. If set, this should be a\n    # dictionary where each key is a string that corresponds to one of the\n    # model inputs. Only has an effect if input_units is defined.\n    input_units_equivalencies = None\n\n    # Covariance matrix can be set by fitter if available.\n    # If cov_matrix is available, then std will set as well\n    _cov_matrix = None\n    _stds = None\n\n    def __init_subclass__(cls, **kwargs):\n...\n\n    def __init__(self, *args, meta=None, name=None, **kwargs):\n...\n\n    def _default_inputs_outputs(self):\n...\n\n    def _initialize_setters(self, kwargs):\n...\n\n    @property\n    def inputs(self):\n...\n\n    @inputs.setter\n    def inputs(self, val):\n...\n\n    @property\n    def outputs(self):\n...\n\n    @outputs.setter\n    def outputs(self, val):\n...\n\n    @property\n    def n_inputs(self):\n...\n\n    @property\n    def n_outputs(self):\n...\n\n    def _calculate_separability_matrix(self):\n...\n\n    def _initialize_unit_support(self):\n...\n\n    @property\n    def input_units_strict(self):\n...\n\n    @property\n    def input_units_allow_dimensionless(self):\n...\n\n    @property\n    def uses_quantity(self):\n...\n\n    def __repr__(self):\n...\n\n    def __str__(self):\n...\n\n    def __len__(self):\n...\n\n    @staticmethod\n    def _strip_ones(intup):\n...\n\n    def __setattr__(self, attr, value):\n...\n\n    def _pre_evaluate(self, *args, **kwargs):\n...\n\n    def get_bounding_box(self, with_bbox=True):\n...\n\n    @property\n    def _argnames(self):\n...\n\n    def _validate_input_shape(self, _input, idx, argnames, model_set_axis, check_model_set_axis):\n...\n\n    def _validate_input_shapes(self, inputs, argnames, model_set_axis):\n...\n\n    def input_shape(self, inputs):\n...\n\n    def _generic_evaluate(self, evaluate, _inputs, fill_value, with_bbox):\n...\n\n    def _post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox, **kwargs):\n...\n\n    @property\n    def bbox_with_units(self):\n...\n\n    def __call__(self, *args, **kwargs):\n...\n\n    def _get_renamed_inputs_as_positional(self, *args, **kwargs):\n...\n\n    # *** Properties ***\n    @property\n    def name(self):\n...\n\n    @name.setter\n    def name(self, val):\n...\n\n    @property\n    def model_set_axis(self):\n...\n\n    @property\n    def param_sets(self):\n...\n\n    @property\n    def parameters(self):\n...\n\n    @parameters.setter\n    def parameters(self, value):\n...\n\n    @property\n    def sync_constraints(self):\n...\n\n    @sync_constraints.setter\n    def sync_constraints(self, value):\n...\n\n    @property\n    def fixed(self):\n...\n\n    @property\n    def bounds(self):\n...\n\n    @property\n    def tied(self):\n...\n\n    @property\n    def eqcons(self):\n...\n\n    @property\n    def ineqcons(self):\n...\n\n    def has_inverse(self):\n...\n\n    @property\n    def inverse(self):\n...\n\n    @inverse.setter\n    def inverse(self, value):\n...\n\n    @inverse.deleter\n    def inverse(self):\n...\n\n    @property\n    def has_user_inverse(self):\n...\n\n    @property\n    def bounding_box(self):\n...\n\n    @bounding_box.setter\n    def bounding_box(self, bounding_box):\n...\n\n    def set_slice_args(self, *args):\n...\n\n    @bounding_box.deleter\n    def bounding_box(self):\n...\n\n    @property\n    def has_user_bounding_box(self):\n...\n\n    @property\n    def cov_matrix(self):\n...\n\n    @cov_matrix.setter\n    def cov_matrix(self, cov):\n...\n\n    @property\n    def stds(self):\n...\n\n    @stds.setter\n    def stds(self, stds):\n...\n\n    @property\n    def separable(self):\n...\n\n    # *** Public methods ***\n\n    def without_units_for_data(self, **kwargs):\n...\n\n    def output_units(self, **kwargs):\n...\n\n    def strip_units_from_tree(self):\n...\n\n    def with_units_from_data(self, **kwargs):\n...\n\n    @property\n    def _has_units(self):\n...\n\n    @property\n    def _supports_unit_fitting(self):\n...\n\n    @abc.abstractmethod\n    def evaluate(self, *args, **kwargs):\n...\n\n    def sum_of_implicit_terms(self, *args, **kwargs):\n...\n\n    def render(self, out=None, coords=None):\n...\n\n    @property\n    def input_units(self):\n...\n\n    @property\n    def return_units(self):\n...\n\n    def _prepare_inputs_single_model(self, params, inputs, **kwargs):\n...\n\n    @staticmethod\n    def _remove_axes_from_shape(shape, axis):\n...\n\n    def _prepare_inputs_model_set(self, params, inputs, model_set_axis_input,\n                                  **kwargs):\n...\n\n    def prepare_inputs(self, *inputs, model_set_axis=None, equivalencies=None,\n                       **kwargs):\n...\n\n    def _validate_input_units(self, inputs, equivalencies=None, inputs_map=None):\n...\n\n    def _process_output_units(self, inputs, outputs):\n...\n\n    @staticmethod\n    def _prepare_output_single_model(output, broadcast_shape):\n...\n\n    def _prepare_outputs_single_model(self, outputs, broadcasted_shapes):\n...\n\n    def _prepare_outputs_model_set(self, outputs, broadcasted_shapes, model_set_axis):\n...\n\n    def prepare_outputs(self, broadcasted_shapes, *outputs, **kwargs):\n...\n\n    def copy(self):\n...\n\n    def deepcopy(self):\n...\n\n    @sharedmethod\n    def rename(self, name):\n...\n\n    def coerce_units(\n        self,\n        input_units=None,\n        return_units=None,\n        input_units_equivalencies=None,\n        input_units_allow_dimensionless=False\n    ):\n...\n\n    @property\n    def n_submodels(self):\n...\n\n    def _initialize_constraints(self, kwargs):\n...\n\n    def _initialize_parameters(self, args, kwargs):\n...\n\n    def _initialize_parameter_value(self, param_name, value):\n...\n\n    def _initialize_slices(self):\n...\n\n    def _parameters_to_array(self):\n...\n\n    def _array_to_parameters(self):\n...\n\n    def _check_param_broadcast(self, max_ndim):\n...\n\n    def _param_sets(self, raw=False, units=False):\n...\n\n    def _format_repr(self, args=[], kwargs={}, defaults={}):\n...\n\n    def _format_str(self, keywords=[], defaults={}):\n...\n\n\nclass FittableModel(Model):\n\n    linear = False\n    # derivative with respect to parameters\n    fit_deriv = None\n    # Flag that indicates if the model derivatives with respect to parameters\n    # are given in columns or rows\n    col_fit_deriv = True\n    fittable = True\n\n\nclass Fittable1DModel(FittableModel):\n    n_inputs = 1\n    n_outputs = 1\n    _separable = True\n\n\nclass Fittable2DModel(FittableModel):\n\n    n_inputs = 2\n    n_outputs = 1\n\n\ndef _make_arithmetic_operator(oper):\n...\n\n\ndef _composition_operator(f, g):\n...\n\n\ndef _join_operator(f, g):\n...\n\n\nBINARY_OPERATORS = {\n    '+': _make_arithmetic_operator(operator.add),\n    '-': _make_arithmetic_operator(operator.sub),\n    '*': _make_arithmetic_operator(operator.mul),\n    '/': _make_arithmetic_operator(operator.truediv),\n    '**': _make_arithmetic_operator(operator.pow),\n    '|': _composition_operator,\n    '&': _join_operator\n}\n\nSPECIAL_OPERATORS = _SpecialOperatorsDict()\n\n\ndef _add_special_operator(sop_name, sop):\n...\n\n\nclass CompoundModel(Model):\n\n    def __init__(self, op, left, right, name=None):\n...\n\n    def _get_left_inputs_from_args(self, args):\n...\n\n    def _get_right_inputs_from_args(self, args):\n...\n\n    def _get_left_params_from_args(self, args):\n...\n\n    def _get_right_params_from_args(self, args):\n...\n\n    def _get_kwarg_model_parameters_as_positional(self, args, kwargs):\n...\n\n    def _apply_operators_to_value_lists(self, leftval, rightval, **kw):\n...\n\n    def evaluate(self, *args, **kw):\n...\n\n    @property\n    def n_submodels(self):\n...\n\n    @property\n    def submodel_names(self):\n...\n\n    def both_inverses_exist(self):\n...\n\n    def _pre_evaluate(self, *args, **kwargs):\n...\n\n    @property\n    def _argnames(self):\n...\n\n    def _post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox, **kwargs):\n...\n\n    def _evaluate(self, *args, **kw):\n...\n\n    @property\n    def param_names(self):\n...\n\n    def _make_leaflist(self):\n...\n\n    def __getattr__(self, name):\n...\n\n    def __getitem__(self, index):\n...\n\n    def _str_index_to_int(self, str_index):\n...\n\n    @property\n    def n_inputs(self):\n...\n\n    @n_inputs.setter\n    def n_inputs(self, value):\n...\n\n    @property\n    def n_outputs(self):\n...\n\n    @n_outputs.setter\n    def n_outputs(self, value):\n...\n\n    @property\n    def eqcons(self):\n...\n\n    @eqcons.setter\n    def eqcons(self, value):\n...\n\n    @property\n    def ineqcons(self):\n...\n\n    @ineqcons.setter\n    def ineqcons(self, value):\n...\n\n    def traverse_postorder(self, include_operator=False):\n...\n\n    def _format_expression(self, format_leaf=None):\n...\n\n    def _format_components(self):\n...\n\n    def __str__(self):\n...\n\n    def rename(self, name):\n...\n\n    @property\n    def isleaf(self):\n...\n\n    @property\n    def inverse(self):\n...\n\n    @property\n    def fittable(self):\n...\n\n    __add__ = _model_oper('+')\n    __sub__ = _model_oper('-')\n    __mul__ = _model_oper('*')\n    __truediv__ = _model_oper('/')\n    __pow__ = _model_oper('**')\n    __or__ = _model_oper('|')\n    __and__ = _model_oper('&')\n\n    def _map_parameters(self):\n...\n\n    def _initialize_slices(self):\n...\n\n    @staticmethod\n    def _recursive_lookup(branch, adict, key):\n...\n\n    def inputs_map(self):\n...\n\n    def _parameter_units_for_data_units(self, input_units, output_units):\n...\n\n    @property\n    def input_units(self):\n...\n\n    @property\n    def input_units_equivalencies(self):\n...\n\n    @property\n    def input_units_allow_dimensionless(self):\n...\n\n    @property\n    def input_units_strict(self):\n...\n\n    @property\n    def return_units(self):\n...\n\n    def outputs_map(self):\n...\n\n    @property\n    def has_user_bounding_box(self):\n...\n\n    def render(self, out=None, coords=None):\n...\n\n    def replace_submodel(self, name, model):\n...\n\n    def _set_sub_models_and_parameter_units(self, left, right):\n...\n\n    def without_units_for_data(self, **kwargs):\n...\n\n    def with_units_from_data(self, **kwargs):\n...\n\n\ndef _get_submodel_path(model, name):\n...\n\n\ndef binary_operation(binoperator, left, right):\n...\n\n\ndef get_ops(tree, opset):\n...\n\n\ndef make_subtree_dict(tree, nodepath, tdict, leaflist):\n...\n\n\n_ORDER_OF_OPERATORS = [('fix_inputs',), ('|',), ('&',), ('+', '-'), ('*', '/'), ('**',)]\nOPERATOR_PRECEDENCE = {}\n\n\ndef fix_inputs(modelinstance, values, bounding_boxes=None, selector_args=None):\n...\n\n\ndef bind_bounding_box(modelinstance, bounding_box, ignored=None, order='C'):\n...\n\n\ndef bind_compound_bounding_box(modelinstance, bounding_boxes, selector_args,\n                               create_selector=None, ignored=None, order='C'):\n...\n\n\ndef custom_model(*args, fit_deriv=None):\n...\n\n\ndef _custom_model_inputs(func):\n...\n\n\ndef _custom_model_wrapper(func, fit_deriv=None):\n...\n\n\ndef render_model(model, arr=None, coords=None):\n...\n\n\ndef hide_inverse(model):\n...\n\n```\n\n### File: astropy/modeling/models.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n# Attach a docstring explaining constraints to all models which support them.\n# Note: add new models to this list\n\nCONSTRAINTS_DOC = \"\"\"\n    Other Parameters\n    ----------------\n    fixed : a dict, optional\n        A dictionary ``{parameter_name: boolean}`` of parameters to not be\n        varied during fitting. True means the parameter is held fixed.\n        Alternatively the `~astropy.modeling.Parameter.fixed`\n        property of a parameter may be used.\n    tied : dict, optional\n        A dictionary ``{parameter_name: callable}`` of parameters which are\n        linked to some other parameter. The dictionary values are callables\n        providing the linking relationship.  Alternatively the\n        `~astropy.modeling.Parameter.tied` property of a parameter\n        may be used.\n    bounds : dict, optional\n        A dictionary ``{parameter_name: value}`` of lower and upper bounds of\n        parameters. Keys are parameter names. Values are a list or a tuple\n        of length 2 giving the desired range for the parameter.\n        Alternatively, the\n        `~astropy.modeling.Parameter.min` and\n        `~astropy.modeling.Parameter.max` properties of a parameter\n        may be used.\n    eqcons : list, optional\n        A list of functions of length ``n`` such that ``eqcons[j](x0,*args) ==\n        0.0`` in a successfully optimized problem.\n    ineqcons : list, optional\n        A list of functions of length ``n`` such that ``ieqcons[j](x0,*args) >=\n        0.0`` is a successfully optimized problem.\n\"\"\"\n\n\nMODELS_WITH_CONSTRAINTS = [\n    AiryDisk2D, Moffat1D, Moffat2D, Box1D, Box2D,\n    Const1D, Const2D, Ellipse2D, Disk2D,\n    Gaussian1D, Gaussian2D,\n    Linear1D, Lorentz1D, RickerWavelet1D, RickerWavelet2D,\n    PowerLaw1D, Sersic1D, Sersic2D,\n    Sine1D, Cosine1D, Tangent1D, ArcSine1D, ArcCosine1D, ArcTangent1D,\n    Trapezoid1D, TrapezoidDisk2D,\n    Chebyshev1D, Chebyshev2D, Hermite1D, Hermite2D, Legendre2D, Legendre1D,\n    Polynomial1D, Polynomial2D, Voigt1D, KingProjectedAnalytic1D,\n    NFW\n]\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "astropy__astropy-14365", "found_files": ["astropy/io/ascii/qdp.py", "astropy/io/ascii/core.py", "astropy/io/ascii/docs.py", "astropy/io/ascii/ui.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"astropy/io/ascii/qdp.py": ["function: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP"], "astropy/io/ascii/core.py": ["variable: FORMAT_CLASSES\nvariable: FAST_CLASSES\nfunction: _check_multidim_table\nclass: CsvWriter\nclass: MaskedConstant\nvariable: masked\nclass: InconsistentTableError\nclass: OptionalTableImportError\nclass: ParameterError\nclass: FastOptionsError\nclass: NoType\nclass: StrType\nclass: NumType\nclass: FloatType\nclass: BoolType\nclass: IntType\nclass: AllType\nclass: Column\nclass: BaseInputter\nclass: BaseSplitter\nclass: DefaultSplitter\nfunction: _replace_tab_with_space\nfunction: _get_line_index\nclass: BaseHeader\nclass: BaseData\nfunction: convert_numpy\nclass: BaseOutputter\nfunction: _deduplicate_names\nclass: TableOutputter\nclass: MetaBaseReader\nfunction: _is_number\nfunction: _apply_include_exclude_names\nclass: BaseReader\nclass:"], "astropy/io/ascii/docs.py": [""]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\nastropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP\n\nastropy/io/ascii/core.py\nvariable: FORMAT_CLASSES\nvariable: FAST_CLASSES\nfunction: _check_multidim_table\nclass: CsvWriter\nclass: MaskedConstant\nvariable: masked\nclass: InconsistentTableError\nclass: OptionalTableImportError\nclass: ParameterError\nclass: FastOptionsError\nclass: NoType\nclass: StrType\nclass: NumType\nclass: FloatType\nclass: BoolType\nclass: IntType\nclass: AllType\nclass: Column\nclass: BaseInputter\nclass: BaseSplitter\nclass: DefaultSplitter\nfunction: _replace_tab_with_space\nfunction: _get_line_index\nclass: BaseHeader\nclass: BaseData\nfunction: convert_numpy\nclass: BaseOutputter\nfunction: _deduplicate_names\nclass: TableOutputter\nclass: MetaBaseReader\nfunction: _is_number\nfunction: _apply_include_exclude_names\nclass: BaseReader\nclass:"}], "related_loc_traj": [{"response": "```\nastropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP\n\nastropy/io/ascii/core.py\nvariable: FORMAT_CLASSES\nvariable: FAST_CLASSES\nfunction: _check_multidim_table\nclass: CsvWriter\nclass: MaskedConstant\nvariable: masked\nclass: InconsistentTableError\nclass: OptionalTableImportError\nclass: ParameterError\nclass: FastOptionsError\nclass: NoType\nclass: StrType\nclass: NumType\nclass: FloatType\nclass: BoolType\nclass: IntType\nclass: AllType\nclass: Column\nclass: BaseInputter\nclass: BaseSplitter\nclass: DefaultSplitter\nfunction: _replace_tab_with_space\nfunction: _get_line_index\nclass: BaseHeader\nclass: BaseData\nfunction: convert_numpy\nclass: BaseOutputter\nfunction: _deduplicate_names\nclass: TableOutputter\nclass: MetaBaseReader\nfunction: _is_number\nfunction: _apply_include_exclude_names\nclass: BaseReader\nclass:", "usage": {"completion_tokens": 300, "prompt_tokens": 3488}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: astropy/io/ascii/qdp.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\ndef _line_type(line, delimiter=None):\n...\n\n\ndef _get_type_from_list_of_lines(lines, delimiter=None):\n...\n\n\ndef _get_lines_from_file(qdp_file):\n...\n\n\ndef _interpret_err_lines(err_specs, ncols, names=None):\n...\n\n\ndef _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n...\n\n\ndef _understand_err_col(colnames):\n...\n\n\ndef _read_table_qdp(qdp_file, names=None, table_id=None, delimiter=None):\n...\n\n\ndef _write_table_qdp(table, filename=None, err_specs=None):\n...\n\n\nclass QDPSplitter(core.DefaultSplitter):\n\n    delimiter = \" \"\n\n\nclass QDPHeader(basic.CommentedHeaderHeader):\n\n    splitter_class = QDPSplitter\n    comment = \"!\"\n    write_comment = \"!\"\n\n\nclass QDPData(basic.BasicData):\n\n    splitter_class = QDPSplitter\n    fill_values = [(core.masked, \"NO\")]\n    comment = \"!\"\n    write_comment = None\n\n\nclass QDP(basic.Basic):\n\n    _format_name = \"qdp\"\n    _io_registry_can_write = True\n    _io_registry_suffix = \".qdp\"\n    _description = \"Quick and Dandy Plotter\"\n\n    header_class = QDPHeader\n    data_class = QDPData\n\n    def __init__(self, table_id=None, names=None, err_specs=None, sep=None):\n...\n\n    def read(self, table):\n...\n\n    def write(self, table):\n...\n\n```\n\n### File: astropy/io/ascii/core.py ###\n```python\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Global dictionary mapping format arg to the corresponding Reader class\nFORMAT_CLASSES = {}\n\n# Similar dictionary for fast readers\nFAST_CLASSES = {}\n\n\ndef _check_multidim_table(table, max_ndim):\n...\n\n\nclass CsvWriter:\n\n    # Random 16-character string that gets injected instead of any\n    # empty fields and is then replaced post-write with doubled-quotechar.\n    # Created with:\n    # ''.join(random.choice(string.printable[:90]) for _ in range(16))\n    replace_sentinel = \"2b=48Av%0-V3p>bX\"\n\n    def __init__(self, csvfile=None, **kwargs):\n...\n\n    def writerow(self, values):\n...\n\n    def writerows(self, values_list):\n...\n\n    def _writerow(self, writerow_func, values, has_empty):\n...\n\n\nclass MaskedConstant(numpy.ma.core.MaskedConstant):\n\n    def __hash__(self):\n...\n\n    def __copy__(self):\n...\n\n    def __deepcopy__(self, memo):\n...\n\n\nmasked = MaskedConstant()\n\n\nclass InconsistentTableError(ValueError):\n    pass\n\n\nclass OptionalTableImportError(ImportError):\n    pass\n\n\nclass ParameterError(NotImplementedError):\n    pass\n\n\nclass FastOptionsError(NotImplementedError):\n    pass\n\n\nclass NoType:\n    pass\n\n\nclass StrType(NoType):\n    pass\n\n\nclass NumType(NoType):\n    pass\n\n\nclass FloatType(NumType):\n    pass\n\n\nclass BoolType(NoType):\n    pass\n\n\nclass IntType(NumType):\n    pass\n\n\nclass AllType(StrType, FloatType, IntType):\n    pass\n\n\nclass Column:\n\n    def __init__(self, name):\n...\n\n\nclass BaseInputter:\n\n    encoding = None\n\n    def get_lines(self, table, newline=None):\n...\n\n    def process_lines(self, lines):\n...\n\n\nclass BaseSplitter:\n\n    delimiter = None\n\n    def process_line(self, line):\n...\n\n    def process_val(self, val):\n...\n\n    def __call__(self, lines):\n...\n\n    def join(self, vals):\n...\n\n\nclass DefaultSplitter(BaseSplitter):\n\n    delimiter = \" \"\n    quotechar = '\"'\n    doublequote = True\n    escapechar = None\n    quoting = csv.QUOTE_MINIMAL\n    skipinitialspace = True\n    csv_writer = None\n    csv_writer_out = StringIO()\n\n    def process_line(self, line):\n...\n\n    def process_val(self, val):\n...\n\n    def __call__(self, lines):\n...\n\n    def join(self, vals):\n...\n\n\ndef _replace_tab_with_space(line, escapechar, quotechar):\n...\n\n\ndef _get_line_index(line_or_func, lines):\n...\n\n\nclass BaseHeader:\n\n    auto_format = \"col{}\"\n    start_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    names = None\n    write_comment = False\n    write_spacer_lines = [\"ASCII_TABLE_WRITE_SPACER_LINE\"]\n\n    def __init__(self):\n...\n\n    def _set_cols_from_names(self):\n...\n\n    def update_meta(self, lines, meta):\n...\n\n    def get_cols(self, lines):\n...\n\n    def process_lines(self, lines):\n...\n\n    def write_comments(self, lines, meta):\n...\n\n    def write(self, lines):\n...\n\n    @property\n    def colnames(self):\n...\n\n    def remove_columns(self, names):\n...\n\n    def rename_column(self, name, new_name):\n...\n\n    def get_type_map_key(self, col):\n...\n\n    def get_col_type(self, col):\n...\n\n    def check_column_names(self, names, strict_names, guessing):\n...\n\n\nclass BaseData:\n\n    start_line = None\n    end_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    write_spacer_lines = [\"ASCII_TABLE_WRITE_SPACER_LINE\"]\n    fill_include_names = None\n    fill_exclude_names = None\n    fill_values = [(masked, \"\")]\n    formats = {}\n\n    def __init__(self):\n...\n\n    def process_lines(self, lines):\n...\n\n    def get_data_lines(self, lines):\n...\n\n    def get_str_vals(self):\n...\n\n    def masks(self, cols):\n...\n\n    def _set_fill_values(self, cols):\n...\n\n    def _set_masks(self, cols):\n...\n\n    def _replace_vals(self, cols):\n...\n\n    def str_vals(self):\n...\n\n    def write(self, lines):\n...\n\n    def _set_col_formats(self):\n...\n\n\ndef convert_numpy(numpy_type):\n...\n\n\nclass BaseOutputter:\n\n    # User-defined converters which gets set in ascii.ui if a `converter` kwarg\n    # is supplied.\n    converters = {}\n\n    # Derived classes must define default_converters and __call__\n\n    @staticmethod\n    def _validate_and_copy(col, converters):\n...\n\n    def _convert_vals(self, cols):\n...\n\n\ndef _deduplicate_names(names):\n...\n\n\nclass TableOutputter(BaseOutputter):\n\n    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]\n\n    def __call__(self, cols, meta):\n...\n\n\nclass MetaBaseReader(type):\n    def __init__(cls, name, bases, dct):\n...\n\n\ndef _is_number(x):\n...\n\n\ndef _apply_include_exclude_names(table, names, include_names, exclude_names):\n...\n\n\nclass BaseReader(metaclass=MetaBaseReader):\n\n    names = None\n    include_names = None\n    exclude_names = None\n    strict_names = False\n    guessing = False\n    encoding = None\n\n    header_class = BaseHeader\n    data_class = BaseData\n    inputter_class = BaseInputter\n    outputter_class = TableOutputter\n\n    # Max column dimension that writer supports for this format. Exceptions\n    # include ECSV (no limit) and HTML (max_ndim=2).\n    max_ndim = 1\n\n    def __init__(self):\n...\n\n    def _check_multidim_table(self, table):\n...\n\n    def read(self, table):\n...\n\n    def inconsistent_handler(self, str_vals, ncols):\n...\n\n    @property\n    def comment_lines(self):\n...\n\n    def update_table_data(self, table):\n...\n\n    def write_header(self, lines, meta):\n...\n\n    def write(self, table):\n...\n\n\nclass ContinuationLinesInputter(BaseInputter):\n\n    continuation_char = \"\\\\\"\n    replace_char = \" \"\n    # If no_continue is not None then lines matching this regex are not subject\n    # to line continuation.  The initial use case here is Daophot.  In this\n    # case the continuation character is just replaced with replace_char.\n    no_continue = None\n\n    def process_lines(self, lines):\n...\n\n\nclass WhitespaceSplitter(DefaultSplitter):\n    def process_line(self, line):\n...\n\n\nextra_reader_pars = (\n    \"Reader\",\n    \"Inputter\",\n    \"Outputter\",\n    \"delimiter\",\n    \"comment\",\n    \"quotechar\",\n    \"header_start\",\n    \"data_start\",\n    \"data_end\",\n    \"converters\",\n    \"encoding\",\n    \"data_Splitter\",\n    \"header_Splitter\",\n    \"names\",\n    \"include_names\",\n    \"exclude_names\",\n    \"strict_names\",\n    \"fill_values\",\n    \"fill_include_names\",\n    \"fill_exclude_names\",\n)\n\n\ndef _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):\n...\n\n\nextra_writer_pars = (\n    \"delimiter\",\n    \"comment\",\n    \"quotechar\",\n    \"formats\",\n    \"strip_whitespace\",\n    \"names\",\n    \"include_names\",\n    \"exclude_names\",\n    \"fill_values\",\n    \"fill_include_names\",\n    \"fill_exclude_names\",\n)\n\n\ndef _get_writer(Writer, fast_writer, **kwargs):\n...\n\n```\n\n### File: astropy/io/ascii/docs.py ###\n```python\nREAD_DOCSTRING = \"\"\"\n    Read the input ``table`` and return the table.  Most of\n    the default behavior for various parameters is determined by the Reader\n    class.\n\n    See also:\n\n    - https://docs.astropy.org/en/stable/io/ascii/\n    - https://docs.astropy.org/en/stable/io/ascii/read.html\n\n...\n\n    encoding : str\n        Allow to specify encoding to read the file (default= ``None``).\n\n    Returns\n    -------\n    dat : `~astropy.table.Table` or <generator>\n        Output table\n\n    \"\"\"\n\n# Specify allowed types for core write() keyword arguments.  Each entry\n# corresponds to the name of an argument and either a type (e.g. int) or a\n# list of types.  These get used in io.ascii.ui._validate_read_write_kwargs().\n# -  The commented-out kwargs are too flexible for a useful check\n# -  'list-list' is a special case for an iterable that is not a string.\nREAD_KWARG_TYPES = {\n    # 'table'\n    \"guess\": bool,\n    # 'format'\n    # 'Reader'\n    # 'Inputter'\n    # 'Outputter'\n    \"delimiter\": str,\n    \"comment\": str,\n    \"quotechar\": str,\n    \"header_start\": int,\n    \"data_start\": (int, str),  # CDS allows 'guess'\n    \"data_end\": int,\n    \"converters\": dict,\n    # 'data_Splitter'\n    # 'header_Splitter'\n    \"names\": \"list-like\",\n    \"include_names\": \"list-like\",\n    \"exclude_names\": \"list-like\",\n    \"fill_values\": \"list-like\",\n    \"fill_include_names\": \"list-like\",\n    \"fill_exclude_names\": \"list-like\",\n    \"fast_reader\": (bool, str, dict),\n    \"encoding\": str,\n}\n\n\nWRITE_DOCSTRING = \"\"\"\n    Write the input ``table`` to ``filename``.  Most of the default behavior\n    for various parameters is determined by the Writer class.\n\n    See also:\n\n    - https://docs.astropy.org/en/stable/io/ascii/\n    - https://docs.astropy.org/en/stable/io/ascii/write.html\n\n    Parameters\n...\n    fast_writer : bool, str\n        Whether to use the fast Cython writer.  Can be `True` (use fast writer\n        if available), `False` (do not use fast writer), or ``'force'`` (use\n        fast writer and fail if not available, mostly for testing).\n    overwrite : bool\n        If ``overwrite=False`` (default) and the file exists, then an OSError\n        is raised. This parameter is ignored when the ``output`` arg is not a\n        string (e.g., a file object).\n\n    \"\"\"\n# Specify allowed types for core write() keyword arguments.  Each entry\n# corresponds to the name of an argument and either a type (e.g. int) or a\n# list of types.  These get used in io.ascii.ui._validate_read_write_kwargs().\n# -  The commented-out kwargs are too flexible for a useful check\n# -  'list-list' is a special case for an iterable that is not a string.\nWRITE_KWARG_TYPES = {\n    # 'table'\n    # 'output'\n    \"format\": str,\n    \"delimiter\": str,\n    \"comment\": (str, bool),\n    \"quotechar\": str,\n    \"header_start\": int,\n    \"formats\": dict,\n    \"strip_whitespace\": (bool),\n    \"names\": \"list-like\",\n    \"include_names\": \"list-like\",\n    \"exclude_names\": \"list-like\",\n    \"fast_writer\": (bool, str),\n    \"overwrite\": (bool),\n}\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
{"instance_id": "django__django-10914", "found_files": ["django/core/files/storage.py", "django/core/files/uploadedfile.py", "django/core/files/temp.py", "django/setup.py", "django/__init__.py", "django/__main__.py"], "additional_artifact_loc_file": {}, "file_traj": {}, "found_related_locs": {"django/core/files/storage.py": ["function: FileSystemStorage.__init__\nfunction: FileSystemStorage._save\nfunction: FileSystemStorage.file_permissions_mode"], "django/core/files/uploadedfile.py": ["class: TemporaryUploadedFile\nclass: InMemoryUploadedFile"], "django/core/files/temp.py": ["variable: gettempdir"]}, "additional_artifact_loc_related": [{"raw_output_loc": "```\ndjango/core/files/storage.py\nfunction: FileSystemStorage.__init__\nfunction: FileSystemStorage._save\nfunction: FileSystemStorage.file_permissions_mode\n\ndjango/core/files/uploadedfile.py\nclass: TemporaryUploadedFile\nclass: InMemoryUploadedFile\n\ndjango/core/files/temp.py\nvariable: gettempdir\n```"}], "related_loc_traj": [{"response": "```\ndjango/core/files/storage.py\nfunction: FileSystemStorage.__init__\nfunction: FileSystemStorage._save\nfunction: FileSystemStorage.file_permissions_mode\n\ndjango/core/files/uploadedfile.py\nclass: TemporaryUploadedFile\nclass: InMemoryUploadedFile\n\ndjango/core/files/temp.py\nvariable: gettempdir\n```", "usage": {"completion_tokens": 67, "prompt_tokens": 1377}, "prompt": "\nPlease look through the following GitHub Problem Description and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nSet default FILE_UPLOAD_PERMISSION to 0o644.\nDescription\n\t\nHello,\nAs far as I can see, the \u200bFile Uploads documentation page does not mention any permission issues.\nWhat I would like to see is a warning that in absence of explicitly configured FILE_UPLOAD_PERMISSIONS, the permissions for a file uploaded to FileSystemStorage might not be consistent depending on whether a MemoryUploadedFile or a TemporaryUploadedFile was used for temporary storage of the uploaded data (which, with the default FILE_UPLOAD_HANDLERS, in turn depends on the uploaded data size).\nThe tempfile.NamedTemporaryFile + os.rename sequence causes the resulting file permissions to be 0o0600 on some systems (I experience it here on CentOS 7.4.1708 and Python 3.6.5). In all probability, the implementation of Python's built-in tempfile module explicitly sets such permissions for temporary files due to security considerations.\nI found mentions of this issue \u200bon GitHub, but did not manage to find any existing bug report in Django's bug tracker.\n\n\n### Skeleton of Relevant Files ###\n\n### File: django/core/files/storage.py ###\n```python\n\n__all__ = (\n    'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',\n    'get_storage_class',\n)\n\n\nclass Storage:\n\n    # The following methods represent a public interface to private methods.\n    # These shouldn't be overridden by subclasses unless absolutely necessary.\n\n    def open(self, name, mode='rb'):\n...\n\n    def save(self, name, content, max_length=None):\n...\n\n    # These methods are part of the public API, with default implementations.\n\n    def get_valid_name(self, name):\n...\n\n    def get_available_name(self, name, max_length=None):\n...\n\n    def generate_filename(self, filename):\n...\n\n    def path(self, name):\n...\n\n    # The following methods form the public API for storage systems, but with\n    # no default implementations. Subclasses must implement *all* of these.\n\n    def delete(self, name):\n...\n\n    def exists(self, name):\n...\n\n    def listdir(self, path):\n...\n\n    def size(self, name):\n...\n\n    def url(self, name):\n...\n\n    def get_accessed_time(self, name):\n...\n\n    def get_created_time(self, name):\n...\n\n    def get_modified_time(self, name):\n...\n\n\n@deconstructible\nclass FileSystemStorage(Storage):\n    # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n    # the file already exists before it's opened.\n    OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n\n    def __init__(self, location=None, base_url=None, file_permissions_mode=None,\n                 directory_permissions_mode=None):\n...\n\n    def _clear_cached_properties(self, setting, **kwargs):\n...\n\n    def _value_or_setting(self, value, setting):\n...\n\n    @cached_property\n    def base_location(self):\n...\n\n    @cached_property\n    def location(self):\n...\n\n    @cached_property\n    def base_url(self):\n...\n\n    @cached_property\n    def file_permissions_mode(self):\n...\n\n    @cached_property\n    def directory_permissions_mode(self):\n...\n\n    def _open(self, name, mode='rb'):\n...\n\n    def _save(self, name, content):\n...\n\n    def delete(self, name):\n...\n\n    def exists(self, name):\n...\n\n    def listdir(self, path):\n...\n\n    def path(self, name):\n...\n\n    def size(self, name):\n...\n\n    def url(self, name):\n...\n\n    def _datetime_from_timestamp(self, ts):\n...\n\n    def get_accessed_time(self, name):\n...\n\n    def get_created_time(self, name):\n...\n\n    def get_modified_time(self, name):\n...\n\n\ndef get_storage_class(import_path=None):\n...\n\n\nclass DefaultStorage(LazyObject):\n    def _setup(self):\n...\n\n\ndefault_storage = DefaultStorage()\n\n```\n\n### File: django/core/files/uploadedfile.py ###\n```python\n\n__all__ = ('UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile',\n           'SimpleUploadedFile')\n\n\nclass UploadedFile(File):\n\n    def __init__(self, file=None, name=None, content_type=None, size=None, charset=None, content_type_extra=None):\n...\n\n    def __repr__(self):\n...\n\n    def _get_name(self):\n...\n\n    def _set_name(self, name):\n...\n\n    name = property(_get_name, _set_name)\n\n\nclass TemporaryUploadedFile(UploadedFile):\n    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n...\n\n    def temporary_file_path(self):\n...\n\n    def close(self):\n...\n\n\nclass InMemoryUploadedFile(UploadedFile):\n    def __init__(self, file, field_name, name, content_type, size, charset, content_type_extra=None):\n...\n\n    def open(self, mode=None):\n...\n\n    def chunks(self, chunk_size=None):\n...\n\n    def multiple_chunks(self, chunk_size=None):\n...\n\n\nclass SimpleUploadedFile(InMemoryUploadedFile):\n    def __init__(self, name, content, content_type='text/plain'):\n...\n\n    @classmethod\n    def from_dict(cls, file_dict):\n...\n\n```\n\n### File: django/core/files/temp.py ###\n```python\n\n__all__ = ('NamedTemporaryFile', 'gettempdir',)\n\ngettempdir = tempfile.gettempdir\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations wrapped with ```.\n"}], "found_edit_locs": {}, "additional_artifact_loc_edit_location": null, "edit_loc_traj": {}}
